---
layout: blog_post
title: "Angular Docker"
author: matt-raible
by: advocate
communities: [java,javascript,devops]
description: "Use Docker to build & deploy an Angular app! Includes how to combine Angular + Spring Boot into a JAR, dockerize it, and deploy to KNative + Cloud Foundry."
tags: [angular, docker, heroku, jarnotwar, spring boot, knative, cloudfoundry, buildpacks]
tweets:
- "A Quick Guide to #Docker with #Angular and Spring Boot. ðŸ‘‡"
- "Angular + Spring Boot + Docker: learn how to create an image with a Dockerfile, with #jib, and using @buildpacks_io!"
- "Combine @angular + @springboot in a single JAR, the use Jib to build a Docker image."
image:
type: conversion
---
:toc: macro
:page-liquid:

Finally, I'll show you how to combine your Angular + Spring Boot app into a single artifact and package it in a Docker container. You'll learn how to deploy it to Heroku using its Container Registry.

== Create a Docker Container for Your Angular App

**Prerequisites:**

* https://docs.docker.com/install/[Docker]
* https://nodejs.org/[Node.js] 12+
* https://adoptopenjdk.net/[Java] 8+

Create a `Dockerfile` that uses the latest version of Node and nginx as a web server.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
COPY nginx.config /etc/nginx/conf.d/default.conf
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

[NOTE]
====
When I was working on this file, I found it handy to comment out the `RUN ng build --prod` line and use the following instead.

[source,shell]
----
RUN mkdir -p dist/notes
RUN echo "Hello, World" > dist/notes/index.html
----

This allows you to skip the lengthy Angular build process.
====

You'll need to create the `nginx.config` file to make nginx SPA-aware.

[source,config]
.notes/nginx.config
----
server {
    listen   80;
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri /index.html;
    }
}
----

Make sure your Docker daemon is running with `docker ps`. Then run the following command to build your Docker image. The `ng-notes` value can be whatever you want to name your image.

[source,shell]
----
docker build -t ng-notes .
----

If it builds successfully, you'll see messages like the following:

[source,shell]
----
Successfully built 382b9cd7d345
Successfully tagged ng-notes:latest
----

You can run it locally on port 4200 using the `docker run` command.

[source,shell]
----
docker run -p 4200:80 ng-notes
----

[NOTE]
====
If you find these `docker` commands hard to remember, you can add a couple scripts to your `package.json` file.

[source,json]
----
"build-docker": "docker build -t ng-notes .",
"docker": "docker run -p 4200:80 ng-notes"
----
====

Since this runs the production build, you'll need to add `\http://localhost:4200` as an allowed origin in your Spring Boot app on Heroku. Run the following command and add it to the end of the existing values.

[source,shell]
----
heroku config:edit --remote heroku
----

TIP: One advantage of doing this is you can run your local Angular app against your production backend. I've found this very useful when debugging and fixing UI issues caused by production data.

To publish your image so you can deploy it, you can use Docker Hub. If you don't already have a Docker Hub account, you can https://hub.docker.com/signup[create one].

Once you have an account, log in and push your image.

[source,shell]
----
docker login
docker image tag ng-notes mraible/ng-notes
docker push mraible/ng-notes
----

This will tag it as `latest` by default. If you want to tag and push a particular version, you can do:

[source,shell]
----
docker image tag ng-notes mraible/ng-notes:1.0
docker push mraible/ng-notes
----

IMPORTANT: Your image will be public by default. If you navigate to your image on Docker Hub in a browser, you can go to its **Settings** tab and make it private.

== Docker on Heroku

Heroku has a https://devcenter.heroku.com/articles/container-registry-and-runtime[couple slick features when it comes to Docker images]. If your project has a `Dockerfile`, you can deploy your app directly using the Heroku Container Registry.

First, log in to the Container Registry.

[source,shell]
----
heroku container:login
----

Then, create a new app.

[source,shell]
----
heroku create
----

Add the Git URL as a new remote to your app.

[source,shell]
----
git remote add docker https://git.heroku.com/<your-app-name>.git
----

You'll need to update `nginx.config` so it reads from a `$PORT` environment variable if it's set, otherwise default it to 80. You can use https://michalzalecki.com/nginx-listen-on-port-docker/[`envsubst` to do this at runtime]. However, the default `envsubst` doesn't allow default variables. The good news is https://github.com/a8m/envsubst[a8m/envsubst] on GitHub does!

Replace your `nginx.config` with the following configuration that defaults to 80 and escapes the `$uri` variable so it's not replaced with a blank value.

[source,config]
.notes/nginx.config
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }
}
----

You'll also need to update your `Dockerfile` so it uses the aforementioned `envsubstr`.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
RUN apk --no-cache add curl
RUN curl -L https://github.com/a8m/envsubst/releases/download/v1.1.0/envsubst-`uname -s`-`uname -m` -o envsubst && \
    chmod +x envsubst && \
    mv envsubst /usr/local/bin
COPY ./nginx.config /etc/nginx/nginx.template
CMD ["/bin/sh", "-c", "envsubst < /etc/nginx/nginx.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"]
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

Then, push your Docker image to Heroku's Container Registry.

[source,shell]
----
heroku container:push web --remote docker
----

Once the push process has completed, release the image of your app:

[source,shell]
----
heroku container:release web --remote docker
----

And open the app in your browser:

[source,shell]
----
heroku open --remote docker
----

You'll need to add your app's URI in Okta and as an allowed origin for the backend with `heroku config:edit`.

See Heroku's https://devcenter.heroku.com/articles/container-registry-and-runtime[Container Registry & Runtime (Docker Deploys)] for more information.

=== Improve Security Headers for Nginx in Docker

If you test your new Nginx in Docker site on https://securityheaders.com/[securityheaders.com], you'll get an F. To solve this, you can modify your `nginx.config` to add security headers.

[source,config]
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'";
    add_header Referrer-Policy "no-referrer, strict-origin-when-cross-origin";
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains";
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
    add_header Feature-Policy "accelerometer 'none'; camera 'none'; microphone 'none'";
}
----

After updating this file, run the following commands:

[source,shell]
----
heroku container:push web --remote docker
heroku container:release web --remote docker
----

Now you should get an **A** !

image::{% asset_path 'blog/angular-deployment/nginx-headers.png' %}[alt=Nginx in Docker score from securityheaders.com,width=800,align=center]

== Combine Your Angular + Spring Boot App into a Single JAR

In the previous sections, you learned how to deploy your Angular and Spring Boot apps separately. Now I'll show you how to combine them into a single JAR for production. You'll still be able to run them independently in development, but deploying them to production will be easier because you won't have to worry about CORS. I'll also convert the OAuth flows so they all happen server-side, which is more secure because the access token won't be stored in the browser.

TIP: Most client-side OAuth libraries keep access tokens in local storage. However, there is a https://gitlab.com/jimdigriz/oauth2-worker[oauth2-worker] project that allows you to store them in a web worker.

Check out your `master` branch and create a new `jar` one.

[source,shell]
----
git checkout master
git checkout -b jar
----

https://developer.okta.com/blog/2020/03/27/spring-oidc-logout-options

// Deploy JAR to CF


== Package Angular + Spring Boot with Docker

[source,kotlin]
----
plugins {
    ...
    id("com.google.cloud.tools.jib") version "2.2.0"
}
----

java -jar build/libs/*.jar

tasks.jibDockerBuild {
dependsOn("bootJar")
}

./gradlew jibDockerBuild -Pprod --image=bootiful-angular

docker run --publish=8080:8080 bootiful-angular

Copy `notes-api/okta.env` to `src/main/docker/.env`.

Change it to:

[source,shell]
----
OKTA_OAUTH2_ISSUER=https://dev-210914.okta.com/oauth2/default
OKTA_OAUTH2_CLIENT_ID=0oaa7psy3dzvqsPjk4x6
OKTA_OAUTH2_CLIENT_SECRET=FJcSFpTC6NHENPPtb7RRWk6sGwPzYa7d7xPcsWsi
----

./gradlew jibDockerBuild -Pprod
docker run --publish=8080:8080 bootiful-angular


cd src/main/docker
docker-compose -f src/main/docker/app.yml up

// todo: warn about using `build` vs. `bootJar` and tests

Deploy to Docker hub by renaming task from jibDockerBuild to jib and running

 ./gradlew jib -Pprod

// Heroku Docker

[source,shell]
----
heroku create
git remote add jib https://git.heroku.com/enigmatic-woodland-19325.git

// attach old or create PostreSQL and Okta
heroku addons:create heroku-postgresql --remote jib

heroku config:get DATABASE_URL --remote jib
heroku config:set SPRING_DATASOURCE_URL=<value-after-@-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_USERNAME=<username-value-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_PASSWORD=<password-value-from-last-command> --remote jib
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote jib

// screenshot + commands to match

heroku addons:create okta --remote jib


// See config with
heroku config --remote jib

Remove _WEB from Okta

docker tag hub.docker.com/mraible/bootiful-angular registry.heroku.com/enigmatic-woodland-19325/web
docker push registry.heroku.com/enigmatic-woodland-19325/web
heroku container:release web --remote jib


Add server.port=${PORT:8080} to application-prod.properties and run  ./gradlew jibDockerBuild -Pprod
----

// CF Docker https://docs.cloudfoundry.org/adminguide/docker.html
// Google Cloud and Kubernetes OR KNative

https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#headers


        http.headers()
                .contentSecurityPolicy("script-src 'self'; report-to /csp-report-endpoint/")
                .and()
                .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.SAME_ORIGIN)
                .and()
                .featurePolicy("accelerometer 'none'; camera 'none'; microphone 'none'")

// todo: try logout


./gradlew jib

or

docker image tag bootiful-angular mraible/bootiful-angular
docker push mraible/bootiful-angular

KNative: https://docs.google.com/document/d/1SLEga2V6N_UaxPcEhDku7gViRJflmtFGljgz-OLUNUQ/edit?ts=5eb1f757

https://skaffold.dev/

https://spring.io/blog/2020/01/27/creating-docker-images-with-spring-boot-2-3-0-m1

== Learn More About Angular and Spring Boot

https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku
https://devcenter.heroku.com/articles/deploying-executable-jar-files
https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku

https://developer.okta.com/blog/2018/07/03/deploy-vue-app-aws
https://developer.okta.com/blog/2018/07/31/use-aws-cloudformation-to-automate-static-site-deployment-with-s3
