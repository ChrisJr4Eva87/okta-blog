---
layout: blog_post
title: "Build a Secure CRUD App with Angular 9.0 and Spring Boot 2.2"
author: mraible
description: "This tutorial demonstrates how to connect Angular and Spring Boot, with OIDC for auth, CSRF protection, and a CSP to prevent XSS."
tags: [angular, spring boot, typescript, kotlin, crud]
tweets:
- "Learn how to connect @angular and @springboot in 2019!"
- "Check out this tutorial on how to build secure apps with @angular and @springboot."
- "Build secure applications with @angular and @springboot in our 2019 howto guide."
// image: blog/spring-boot-2-angular-9/secure-bootiful-angular.png
---
:toc: macro
:page-liquid:
:experimental:

Angular is a web framework for building mobile and desktop applications. It's first version, AngularJS, was one of the first JavaScript MVC frameworks to dominate the web landscape. Developers loved it and it rose to popularity in the early 2010s. AngularJS 1.0 was released on June 14, 2014. Angular 9 was recently released, giving Angular quite a popularity run in the land of web frameworks.

Spring Boot is one of the most popular frameworks for developing Java applications and REST APIs. It also has first class support for Kotlin!

Spring Boot 1.0 was released on April 1, 2014 and revolutionized the way Java developers write Spring apps. Instead of writing a lot of boilerplate XML or JavaConfig with annotations, Spring Boot introduced the idea of pre-configured _starters_ with smart defaults.

== What's New In Angular 9?

Angular 9's biggest new feature is Ivy. Ivy is Angular's new compiler and renderer. The renderer is the engine that takes your components and templates and translates them into instructions that manipulate the DOM. Ivy is an internal component, so you don't interact with it directly. However, it can have a big impact on your code, yielding much smaller JavaScript bundles and increasing performance.

Simply put: upgrading to Angular 9 will make your web apps faster!

Other noteable features in Angular 9 include:

1. Enhancements to Angular CLI to support internationalization (i18n).
2. Type-safe improvements to `TestBed` for unit testing.

To use Angular CLI's i18n feature, you simply need to add the `i18n` attribute to your text elements, then run `ng xi18n` to extract your localizable text into a file.

`TestBed.inject(Component)` is the new way to get references to components in tests. `TestBed.get(Component)` is deprecated.

== What's New in Spring Boot 2.2?

Spring Boot 2.2 was released in September 2019 and focuses on performance improvements and reduced memory usage. It adds Java 13 support, RSocket support, and the ability to group health indicators. This can be useful if you're deploying to Kubernetes and want different groups of indicators for "liveness" and "readiness" probes.

In this post, I'll show you how to build a CRUD application with Angular 9 and Spring Boot 2.2. Along the way, I'll do my best to weave in security tips and how to make your applications more secure.

// Mention 10 Excellent Ways to Secure Spring Boot. TLS, mkcert, CSRF, dependabot, CSP, OIDC.

**Prerequisites:**

* https://nodejs.org/[Node 12]+
* https://adoptopenjdk.net/[Java 11]+
* An https://developer.okta.com/signup/[Okta Developer Account]

To install these Node and Java on a Mac, Linux, or Windows Subsystem for Linux (WSL), you can use https://docs.brew.sh/Installation[Homebrew].

[source,shell]
----
brew install node
brew tap AdoptOpenJDK/openjdk
brew cask install adoptopenjdk11
----

You can also use https://sdkman.io[SDKMAN!] to install Java 11.

[source,shell]
----
sdk install java 11.0.5.hs-adpt
----

You can refer to the table of contents below for the steps in this tutorial.

toc::[]

== Create an Angular 9 App

To create an Angular 9 app, you first need to install Angular CLI.

[source,shell]
----
npm install -g @angular/cli@9.0.0-rc.2
----

Then create a directory on your hard-drive called `angular-spring-boot`. Open a terminal window and navigate to this directory. Run `ng new` to create an Angular application.

[source,shell]
----
ng new notes --routing --style css
----

This will take a minute or two to complete, depending on your internet speed and hardware. Once it's finished, navigate into the directory and run `ng serve`.

[source,shell]
----
ng serve
----

Open your browser to `http://localhost:4200` and you'll see the default homepage.

image::{% asset_path 'blog/spring-boot-2-angular-9/default-homepage.png' %}[alt=Angular default homepage,width=800,align=center]

Stop the `ng serve` process using kbd:[Ctrl+C] in your terminal.

== Add Angular Authentication using OpenID Connect

OpenID Connect (also called OIDC) is an identity later that's based on the OAuth 2.0 specification. It leverages JSON Web Tokens (JWT) to provide an ID token and other features like discoverability and a `/userinfo` endpoint.

Okta has Authentication and User Management APIs that reduce development time with instant-on, scalable user infrastructure. Okta's intuitive API and expert support make it easy for developers to authenticate, manage, and secure users + roles in any application.

To add OIDC login support to your Angular 9 app, you'll first need an https://developer.okta.com/signup[free Okta developer account]. After you've created your account and logged in to your Okta dashboard, create a new OIDC app using the following steps:

1. Navigate to **Applications** > **Add Application**
2. Select **Single-Page App** and click **Next**
3. Provide a name (e.g., `Angular 9`) and change the Login redirect URI to `http://localhost:4200/implicit/callback`
4. Select **Authorization Code** as a Grant type
5. Click **Done**

Your app's settings should resemble the following.

image::{% asset_path 'blog/spring-boot-2-angular-9/angular9-oidc-settings.png' %}[alt=Angular OIDC App Settings,width=700,align=center]

At the bottom of the screen, you'll see your app's Client ID. You might also notice that **Use PKCE** is selected. This setting provides the maximum level of security you can currently have for single-page apps when using OIDC for auth.

TIP: To learn more about PKCE (pronounced "pixy"), see link:/blog/2019/08/22/okta-authjs-pkce[Implement the OAuth 2.0 Authorization Code with PKCE Flow].

Copy your client ID and your issuer URI (from **API** > **Authorization Servers**) into the following command.

[source,shell]
----
ng add @oktadev/schematics --issuer=$issuer --clientId=$clientId
----

This adds Okta's Angular SDK and configures OIDC authentication for your app.

image::{% asset_path 'blog/spring-boot-2-angular-9/oktadev-schematics.png' %}[alt=OktaDev Schematics in Action,width=800,align=center]

Start your app again using `ng serve -o` and you'll see a **Login** button in the bottom left.

image::{% asset_path 'blog/spring-boot-2-angular-9/angular-login-button.png' %}[alt=Login button,width=800,align=center]

Click on it and you'll be redirected to Okta to login.

image::{% asset_path 'blog/spring-boot-2-angular-9/okta-login.png' %}[alt=Okta Login form,width=425,align=center]

Enter valid credentials and you'll be redirected back to your app. There will now be a **Logout** button, indicating that you've authenticated successfully.

image::{% asset_path 'blog/spring-boot-2-angular-9/angular-logout-button.png' %}[alt=Logout button,width=800,align=center]

Now that you've created a secure Angular 9 app, let's create a Spring Boot app to serve up data with a REST API.

== Create a Spring Boot 2.2 App

The good folks at Pivotal created https://start.spring.io[start.spring.io] to help you create Spring Boot apps quickly with minimal fuss. This site is a Spring Boot app that has a REST API you can talk to with https://httpie.org/[HTTPie].

Kotlin is an intriguing language for Spring developers because it reduces boilerplate code and allows succinct, effective code. Kotlin is 100% interoperable with Java, so you can continue to use the Java libraries and frameworks you know and love. Not only that, but Spring has first-class support for Kotlin.

Create a new Spring Boot app that uses Java 11, Kotlin, Gradle, and has the necessary dependencies to create a secure CRUD API.

[source,shell]
----
http https://start.spring.io/starter.zip javaVersion==11 language==kotlin \
 artifactId==notes-api groupId=com.okta.developer packageName==com.okta.developer.notes \
 type==gradle-project dependencies==h2,data-jpa,data-rest,okta,web -d
----

Run this command in a terminal and a `notes-api.zip` file will be downloaded. Expand it into the `angular-spring-boot/notes-api` directory.

[source,shell]
----
unzip notes-api.zip -d angular-spring-boot/notes-api
----

You can also use https://start.spring.io[start.spring.io] in your browser to create this same app.

image::{% asset_path 'blog/spring-boot-2-angular-9/start.spring.io.png' %}[alt=Create app with start.spring.io,width=800,align=center]

=== Secure Spring Boot with Spring Security, OAuth 2.0, and OIDC

Because you selected Okta as a dependency, you'll need to create an OIDC app for it to authenticate with Okta. You could use the client ID from your Angular app, but if you ever want to allow people to login to your Spring Boot app, it'll need it's own OIDC app.

Log in to your Okta dashboard, then:

* Go to **Applications** > **Add Application**
* Select **Web** and click **Next**
* Give it a name like `Spring Boot 2.2` and change the Login redirect URI to `http://localhost:8080/login/oauth2/code/okta`
* Click **Done**

Your app's settings should look as follows.

image::{% asset_path 'blog/spring-boot-2-angular-9/spring-boot-oidc-settings.png' %}[alt=Spring Boot OIDC Settings,width=700,align=center]

You _could_ copy your app's OIDC settings to `src/main/resources/application.properties`:

[source,properties]
----
okta.oauth2.issuer=https://{yourOktaDomain}/oauth2/default
okta.oauth2.client-id={yourClientId}
okta.oauth2.client-secret={yourClientSecret}
----

However, **you should never store secrets in source control**!

To prevent you from checking secrets in, you can use https://github.com/awslabs/git-secrets[git-secrets]. For this example, copy your settings into a new `okta.env` file and ignore `*.env` in your `.gitignore`.

[source,shell]
----
export OKTA_OAUTH2_ISSUER=https://{yourOktaDomain}/oauth2/default
export OKTA_OAUTH2_CLIENT_ID={yourClientId}
export OKTA_OAUTH2_CLIENT_SECRET={yourClientSecret}
----

After replacing the `{...}` placeholders with your values, run `source okta.env` to set these environment variables.

Then start your app using `./gradlew bootRun`. Open `http://localhost:8080` in a browser and you'll be redirected to Okta to sign in.

TIP: If you don't get prompted, it's because you're already logged in. Try it in an incognito window to see the the full login flow.

=== Spring Boot as an Auth 2.0 Resource Server

Your Spring Boot API is now secure, but it's not configured to look for an `Authorization` header with an access token in it. You need to write some code to make your Spring Boot API an OAuth 2.0 resource server.

Create a `SecurityConfiguration.kt` class in the same directory as `DemoApplication.kt`:

[source,kotlin]
----
package com.okta.developer.notes

import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter

@Configuration
class SecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        //@formatter:off
        http
            .authorizeRequests().anyRequest().authenticated()
                .and()
            .oauth2Login()
                .and()
            .oauth2ResourceServer().jwt()
		//@formatter:on
    }
}
----

NOTE: The `oauth2Login()` configuration is not necessary for this example to work. It's only needed if you want to require authentication from a browser.

== Add a Notes REST API with Spring Data REST

Start by creating a new `Note` entity in `src/main/kotlin/.../notes/DemoApplication.kt`.

[source,kotlin]
----
package com.okta.developer.notes

import com.fasterxml.jackson.annotation.JsonIgnore
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import javax.persistence.Entity
import javax.persistence.GeneratedValue
import javax.persistence.Id

@SpringBootApplication
class DemoApplication

fun main(args: Array<String>) {
    runApplication<DemoApplication>(*args)
}

@Entity
data class Note(@Id @GeneratedValue var id: Long? = null,
                var title: String? = null,
                var text: String? = null,
                @JsonIgnore var user: String? = null)
----

Kotlin's https://kotlinlang.org/docs/reference/data-classes.html[data classes] are built to hold data. By adding the `data` keyword, your class will get `equals()`, `hashCode()`, `toString()`, and a `copy()` function. The `Type? = null` syntax means the arguments are nullable when creating a new instance of the class.

Create a `NotesRepository` for persisting the data in your notes. Add the following lines of code just below your `Note` entity.

[source,kotlin]
----
@RepositoryRestResource
interface NotesRepository : JpaRepository<Note, Long>
----

The `extends` syntax differs from Java and is a lot more concise (a colon instead of `extends`).

To automatically add the username to a note when it’s created, add a `RepositoryEventHandler` that is invoked before creating the record.

[source,kotlin]
----
@Component
@RepositoryEventHandler(Note::class)
class AddUserToNote {

    @HandleBeforeCreate
    fun handleCreate(note: Note) {
        val username: String =  SecurityContextHolder.getContext().getAuthentication().name
        println("Creating note: $note with user: $username")
        note.user = username
    }
}
----

Create a `DataInitializer.kt` class that populates the database with some default data on startup.

[source,kotlin]
----
package com.okta.developer.notes

import org.springframework.boot.ApplicationArguments
import org.springframework.boot.ApplicationRunner
import org.springframework.stereotype.Component

@Component
class DataInitializer(val repository: NotesRepository) : ApplicationRunner {

    @Throws(Exception::class)
    override fun run(args: ApplicationArguments) {
        listOf("Note 1", "Note 2", "Note 3").forEach {
            repository.save(Note(title = it, user = "user"))
        }
        repository.findAll().forEach { println(it) }
    }
}
----

Restart your Spring Boot app and you should see the following printed to your console on startup.

[source,shell]
----
Note(id=1, title=Note 1, text=null, user=user)
Note(id=2, title=Note 2, text=null, user=user)
Note(id=3, title=Note 3, text=null, user=user)
----

Create a `UserController.kt` class (in the same directory as `DemoApplication.kt`) and use it to filter notes by the currently logged-in user. While you're at it, add a `/user` endpoint that returns the user's information.

[source,kotlin]
----
package com.okta.developer.notes;

import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.core.oidc.user.OidcUser
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.security.Principal

@RestController
class UserController(val repository: NotesRepository) {

    @GetMapping("/user/notes")
    fun notes(principal: Principal): List<Note> {
        println("Fetching notes for user: ${principal.name}")
        val notes = repository.findAllByUser(principal.name)
        if (notes.isEmpty()) {
            return listOf()
        } else {
            return notes
        }
    }

    @GetMapping("/user")
    fun user(@AuthenticationPrincipal user: OidcUser): OidcUser {
        return user;
    }
}
----

The `findAllByUser()` method doesn't exist on `NotesRepository`, so you'll need to add it. Thanks to Spring Data JPA, all you need to do is add the method definition to the interface, and it will handle generating the finder method in the implementation.

[source,kotlin]
----
interface NotesRepository : JpaRepository<Note, Long> {
    fun findAllByUser(name: String): List<Note>
}
----

To prevent conflicting paths with the REST endpoints created by `@RepositoryRestResource`, set the base path to `/api` in `application.properties`.

[source,properties]
----
spring.data.rest.base-path=/api
----

Restart your Spring Boot app, navigate to `http://localhost:8080/user` and you'll see a whole plethora of details about your account. Opening `http://localhost:8080/api/notes` will show the default notes entered by `DataInitializer` component.

=== Add a CORS Filter for Angular

In order for your Angular app (on port 4200) to communicate with your Spring Boot app (on port 8080), you have to enable CORS (cross-origin resource sharing). You can do this by giving your `DemoApplication` a body and defining a `corsFilter` bean inside it.

[source,kotlin]
----
@SpringBootApplication
class DemoApplication {

	@Bean
	fun simpleCorsFilter(): FilterRegistrationBean<CorsFilter> {
		val source = UrlBasedCorsConfigurationSource()
		val config = CorsConfiguration()
		config.allowCredentials = true
		config.allowedOrigins = listOf("http://localhost:4200")
		config.allowedMethods = listOf("*");
		config.allowedHeaders = listOf("*")
		source.registerCorsConfiguration("/**", config)
		val bean = FilterRegistrationBean(CorsFilter(source))
		bean.order = Ordered.HIGHEST_PRECEDENCE
		return bean
	}
}
----

To see how your final `DemoApplication` file should look, you can [view the completed version in GitHub].

Now that your API is working, it's time to develop a UI for it with Angular 9!

== Add a Notes CRUD Feature in Angular

Angular Schematics is a workflow tool that allows you to manipulate any project that has a `package.json`. Angular CLI is based on Schematics. OktaDev Schematics uses Schematics to update and add new files to projects. There's even an https://github.com/manfredsteyer/angular-crud[angular-crud] schematic! This allows you to generate CRUD (create, read, update, and delete) functionality from a JSON file.

Install angular-crud using npm:

[source,shell]
----
npm i -D angular-crud
----

In your Angular `notes` app, create a `src/app/notes` directory.

[source,shell]
----
mkdir -p src/app/notes
----

Then, create a `model.json` file in it that defines metadata that's used when generating files.

[source,json]
----
{
    "title": "Notes",
    "entity": "note",
    "api": {
      "url": "http://localhost:8080/api/notes"
    },
    "filter": [
      "title"
    ],
    "fields": [
      {
        "name": "id",
        "label": "Id",
        "isId": true,
        "readonly": true,
        "type": "number"
      },
      {
        "name": "title",
        "type": "string",
        "label": "Title"
      },
      {
        "name": "text",
        "type": "string",
        "label": "Text"
      }
    ]
}
----

Navigate to the `src/app/notes` directory in a terminal window, and run the command below to generate CRUD screens.

[source,shell]
----
ng g angular-crud:crud-module notes
----

// todo: fix or create new schematic (maybe in OktaDev Schematics)
// maybe use https://ng-bootstrap.github.io/#/components/table/overview?

// todo: move URL into environment.ts, auto-search in list, modify search to only show your notes

// todo: remove placeholder content in app.component.html

// todo: add a link to View Notes in home.component.html

Navigate to your Angular project's root directory and run `ng serve`. Log in and click the **View Notes** link. You should see a list screen like the one below. Since you haven't created any notes that are tied to your user, none are returned.

// image

Add a few new notes and you should be able to see them in the list, filter them by title, and edit or delete them.

// screenshots

== Lock Down Spring Boot with Recommended Security Practices

In link:/blog/2018/07/30/10-ways-to-secure-spring-boot[10 Excellent Ways to Secure Your Spring Boot Application], I recommended a few Spring Boot-specific items:

1. Use HTTPS
2. Enable Cross-Site Request Forgery (CSRF) Protection
3. Use a Content Security Policy (CSP) to Prevent XSS Attacks
4. Use OpenID Connect for Authentication

You've already implemented #4 with Okta, but what about the others?

You can use https://github.com/FiloSottile/mkcert[mkcert] for to generate local, valid TLS certificates. To force, HTTPS, you just need to configure Spring Security. CSRF protection and a CSP can be configured with Spring Security.

Modify your `SecurityConfiguration` class with these security enhancements.

====
[source,kotlin]
----
class SecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        //@formatter:off
        http
            .authorizeRequests().anyRequest().authenticated()
                .and()
            .oauth2Login()
                .and()
            .oauth2ResourceServer().jwt()

        http.requiresChannel().anyRequest().requiresSecure(); // <1>

        http.csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()); // <2>

        http.headers()
            .contentSecurityPolicy("script-src 'self'; report-uri /csp-report-endpoint/"); // <3>
        //@formatter:on
    }
}
----
<1> Force HTTPS
<2> Configure the CSRF Cookie so it can be read by JavaScript
<3> Configure a CSP that only allows local scripts
====

Angular's `HttpClient` has built-in support for the client-side half of the CSRF protection. It'll read the cookie sent by Spring Boot and return it in a `X-XSRF-TOKEN` header.

In this particular example, the CSP won't be used since Angular is a separate app. However, if you were to include the Angular app in your Spring Boot artifact, it'd come in handy.

TIP: Once you've deployed your Spring Boot app to a public URL, you can test your CSP headers are working with https://securityheaders.com/[securityheaders.com].

https://www.grapecity.com/blogs/what-to-expect-in-angular-9
https://spring.io/blog/2019/10/16/spring-boot-2-2-0
Angular Material > https://developer.okta.com/blog/2017/09/19/build-a-secure-notes-application-with-kotlin-typescript-and-okta
https://angular.io/guide/security
