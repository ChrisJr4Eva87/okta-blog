---
layout: blog_post
title: "How to Succeed with Angular Deployment"
author: matt-raible
by: advocate
communities: [java,javascript,devops]
description: "Learn how to deploy your Angular + Spring Boot App to Heroku, Firebase, Netlify, AWS, and Azure."
tags: [angular, deployment, heroku, firebase, netlify, aws s3, azure]
tweets:
- "You've built an Angular + Spring Boot application and now you need to deploy it. This tutorial shows you how!"
- "Deploy @angular to Heroku, Firebase, Netlify, AWS, and Azure with this in-depth tutorial."
- "A Guide for deploying @angular and @springboot applications in 2020. ðŸ‘‡"
image:
type: conversion
---
:toc: macro
:page-liquid:

// How to Succeed with Angular Deployment = 71
// How to Succeed with Angular + Spring Boot Deployment = 68
// Deploy Angular to the Cloud = 61
// The Ultimate Angular Deployment Guide = 57
// Angular Deployment Guide for 2020 = 47
// Angular Deployment: The Ultimate Guide = 58
// Angular + Spring Boot Deployment: The Ultimate Guide = 62
// todo: add Spring Boot to title. reason: angular deployment is 1900, angular spring boot is 3600

One of the more popular combinations of frontend and backend frameworks is Angular + Spring Boot. I've written several tutorials on how to combine the two, from keeping them as separate apps, to combining them into a single artifact. But what about deployment?

Developers ask me from time-to-time what's the best way to do Angular deployment? In this tutorial, I'll show you several options. I'll start by showing you how to deploy a Spring Boot app to Heroku. Then I'll show how to deploy a separate Angular app to Heroku.

There's lots of tutorials and knowledge in the Java community about how to deploy Spring Boot apps, so I'll leave the backend on Heroku and show other Angular deployment options, including Firebase, Netlify, AWS S3, and Azure.

Finally, I'll show you how to combine your Angular + Spring Boot app into a single artifact and package it in a Docker container. You'll learn how to deploy it to Heroku using its Container Registry.

toc::[]

== Create an Angular + Spring Boot App

Since this tutorial is about deployment moreso than app creation, you can start with an existing Angular + Spring Boot app I created previously. It's a note-taking app that uses Kotlin and Spring Boot 2.2 on the backend and Angular 9 on the frontend. It's secured with OpenID Connect (OIDC). If you'd like to see how I built it, you can read the following tutorials:

* https://developer.okta.com/blog/2020/01/06/crud-angular-9-spring-boot-2[Build a CRUD App with Angular 9 and Spring Boot 2.2]
* https://developer.okta.com/blog/2020/03/02/angular-bootstrap[Build Beautiful Angular Apps with Bootstrap]

One of the slick features of this app is its full-featured data table that allows sorting, searching, and pagination. This feature is powered by NG Bootstrap and Spring Data JPA. Below is a screenshot.

image::{% asset_path 'blog/angular-deployment/notes-list-with-sorting.png' %}[alt=Notes list with sorting,width=800,align=center]

Clone the application into an `okta-angular-deployment-example` directory.

[source,shell]
----
git clone https://github.com/oktadeveloper/okta-angular-bootstrap-example.git \
 okta-angular-deployment-example
----

**Prerequisites:**

* https://docs.docker.com/get-docker/[Docker]
* https://adoptopenjdk.net/[Java 11]+
* https://nodejs.org/[Node 12]+
* An https://developer.okta.com/signup/[Okta Developer Account]

=== Secure Your Angular + Spring Boot App with OIDC

To begin, you'll need to https://signup.heroku.com/login[create a Heroku account]. If you already have a Heroku account, log in to it. Once you're logged in, create a new app.

image::{% asset_path 'blog/angular-deployment/heroku-create-app.png' %}[alt=Create Heroku app,width=700,align=center]

After creating your app, click on the **Resources** tab and add the **Okta** add-on.

image::{% asset_path 'blog/angular-deployment/okta-add-on.png' %}[alt=Okta Add-On,width=475,align=center]

CAUTION: If you haven't entered a credit card for your Heroku account, you will get an error. This is because Heroku requires you to have a credit card on file to use any of their add-ons, even for free ones. This is part of Heroku's assurance to guard against misuse (real person, real credit card, etc.). I think this is a good security practice. Add a credit card to continue.

Click **Provision** and wait 20-30 seconds while your Okta account is created and OIDC apps are registered. Now go to your app's **Settings** tab and click the **Reveal Config Vars** button. The Config Vars displayed are the environment variables you can use to configure both Angular and Spring Boot for OIDC authentication.

image::{% asset_path 'blog/angular-deployment/heroku-config-vars.png' %}[alt=Okta Add-On,width=800,align=center]

Create an `okta.env` file in the `okta-angular-deployment-example/notes-api` directory and copy the config vars into it, where `$OKTA_*` is the value from Heroku.

[source,shell]
----
export OKTA_OAUTH2_ISSUER=$OKTA_OAUTH2_ISSUER
export OKTA_OAUTH2_CLIENT_ID=$OKTA_OAUTH2_CLIENT_ID_WEB
export OKTA_OAUTH2_CLIENT_SECRET=$OKTA_OAUTH2_CLIENT_SECRET_WEB
----

Start your Spring Boot app by navigating to the `notes-api` directory, sourcing this file, and starting your app.

[source,shell]
----
source okta.env
./gradlew bootRun
----

// todo: add note about copy/pasting them as environment variables in IntelliJ

Next, configure Angular for OIDC auth by modifying its `auth-routing.module.ts` to use the generated issuer, client ID, and update the callback URL.

[source,typescript]
.notes/src/app/auth-routing.module.ts
----
const oktaConfig = {
  issuer: '$OKTA_OAUTH2_ISSUER',
  redirectUri: window.location.origin + '/authorization-code/callback',
  clientId: '$OKTA_OAUTH2_CLIENT_ID_SPA',
  pkce: true
};

const routes: Routes = [
  ...
  {
    path: 'authorization-code/callback',
    component: OktaCallbackComponent
  }
];
----

By default, Heroku registers a SPA app on the same port (`8080`) as a web app. This means you need to log in to your Okta dashboard and add a new redirect URI for local development. Luckily, Heroku makes this easy to do. Go to **Resources** and click on the **okta** add on. This will log you in to your Okta dashboard. Navigate to **Applications** > **Heroku Created OIDC App - browser** > **General** > **Edit**.

Add `http://localhost:4200/authorization-code/callback` as a Login redirect URI and `http://localhost:4200` as a Logout redirect URI. You'll also need to add `http://localhost:4200` as a trusted origin in **API** > **Trusted Origins**.

Install your Angular app's dependencies and start it.

[source,shell]
----
npm i
ng serve
----

Open `http://localhost:4200` in your browser.

image::{% asset_path 'blog/angular-deployment/angular-home.png' %}[alt=Angular Home,width=800,align=center]

Click the **Login** button. You should be logged in straight-away since you're already logged in to Okta. If you want to see the full authentication flow, log out, or try it in a private window. You can use the `$OKTA_ADMIN_EMAIL` and `$OKTA_ADMIN_PASSWORD` from your Heroku config variables for credentials. Create a note to make sure everything works.

image::{% asset_path 'blog/angular-deployment/first-note.png' %}[alt=First note,width=800,align=center]

Commit your progress to Git from the `okta-angular-deployment-example` directory.

[source,shell]
----
git commit -am "Add Okta OIDC Configuration"
----

TIP: The generated credentials are cryptic and hard to remember. Create a user on Okta that's easy to remember, or save the credentials in something like 1Password.

== Prepare Angular + Spring Boot for Production

There are a couple things you should do to make your app ready for production.

1. Make sure you're using the latest releases
2. Configure production URLs
3. Use PostgreSQL for the production database

You're going to want to continue to develop it locally, so you'll want a production mode, as well as a development mode.

=== Update Spring Boot and Angular Dependencies

I'm the type of developer that likes to use the latest releases of open source libraries. I do this to take advantage of new features, performance optimizations, and security fixes.

There's a https://github.com/patrikerdes/gradle-use-latest-versions-plugin[Gradle Use Latest Versions Plugin] that provides a task to update dependencies to the latest version. Configure it by adding the following to the `plugins` block at the top of `notes-api/build.gradle.kts`.

[source,kotlin]
----
plugins {
    id("se.patrikerdes.use-latest-versions") version "0.2.13"
    id("com.github.ben-manes.versions") version "0.28.0"
    ...
}
----

Then run the following command in the `notes-api` directory to update your dependencies to the latest released versions.

[source,shell]
----
./gradlew useLatestVersions
----

You can verify everything still works by running `./gradlew bootRun` and navigating to `http://localhost:8080/api/notes`. You should be redirected to Okta to log in, then back to your app.

TIP: If your app fails to start, you need to run `source okta.env` first.

For the Angular client, you can use https://www.npmjs.com/package/npm-check-updates[npm-check-updates] to upgrade npm dependencies.

[source,shell]
----
npm i -g npm-check-updates
----

Then run the following commands in the `notes` directory:

[source,shell]
----
ncu -u
npm i
npm audit fix
ng serve
----

Confirm you can still log in at `http://localhost:4200`.

Commit all your changes to source control.

[source,shell]
----
git commit -am "Update dependencies to latest versions"
----

=== Configure Production URLs

There are a couple places where `localhost` is hard-coded:

1. `notes-api/src/main/kotlin/.../DemoApplication.kt` has `\http://localhost:4200`
2. `notes/src/app/shared/okta/auth-interceptor.ts` has `\http://localhost`
3. `notes/src/app/note/note.service.ts` has `\http://localhost:8080`

You need to change Spring Boot's code so other origins can make CORS requests. Angular's code needs updating so access tokens will be sent to production URLs and API requests are sent to the correct endpoint.

Open the root directory in your favorite IDE and configure it so it loads `notes-api` as a Gradle project. Open `DemoApplication.kt` and change the `simpleCorsFilter` bean so it configures the allowed origins from your Spring environment.

[source,kotlin]
.src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
----
import org.springframework.beans.factory.annotation.Value

@SpringBootApplication
class DemoApplication {

    @Value("#{ @environment['allowed.origins'] ?: {} }")
    private lateinit var allowedOrigins: List<String>

    @Bean
    fun simpleCorsFilter(): FilterRegistrationBean<CorsFilter> {
        val source = UrlBasedCorsConfigurationSource()
        val config = CorsConfiguration()
        config.allowCredentials = true
        config.allowedOrigins = allowedOrigins
        config.allowedMethods = listOf("*");
        config.allowedHeaders = listOf("*")
        source.registerCorsConfiguration("/**", config)
        val bean = FilterRegistrationBean(CorsFilter(source))
        bean.order = Ordered.HIGHEST_PRECEDENCE
        return bean
    }
}
----

Define the `allowed.origins` property in `src/main/resources/application.properties`.

[source,properties]
----
allowed.origins=http://localhost:4200
----

Angular has an https://angular.io/guide/build[environment concept] built-in. When you run `ng build --prod` to create a production build, it replaces `environment.ts` with `environment.prod.ts`.

Open `environment.ts` and add an `apiUrl` variable for development.

[source,typescript]
.notes/src/environments/environment.ts
----
export const environment = {
  production: false,
  apiUrl: 'http://localhost:8080'
};
----

Edit `environment.prod.ts` in the same directory to point to your production Heroku URL.

[source,typescript]
.notes/src/environments/environment.prod.ts
----
export const environment = {
  production: false,
  apiUrl: 'https://bootiful-angular.herokuapp.com'
};
----

Update `auth-interceptor.ts` to use `environment.apiUrl`.

[source,typescript]
.notes/src/app/shared/okta/auth.interceptor.ts
----
import { environment } from '../../../environments/environment';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {

  ...

  private async handleAccess(request: HttpRequest<any>, next: HttpHandler): Promise<HttpEvent<any>> {
    const allowedOrigins = [environment.apiUrl];
    ...
  }
}
----

Update `notes.service.ts` as well.

[source,typescript]
.notes/src/app/note/note.service.ts
----
import { environment } from '../../environments/environment';
...

export class NoteService {
  ...
  api = `${environment.apiUrl}/api/notes`;
  ...

  find(filter: NoteFilter): Observable<Note[]> {
    ...

    const userNotes = `${environment.apiUrl}/user/notes`;
    ...
  }
}
----

=== Use PostgreSQL for the Production Database

H2 is a SQL database that works nicely for development. In production, you're going to want something a little more robust. Personally, I like PostgreSQL, so I'll use it in this example.

Similar to Angular's environments, Spring and Maven have profiles that allow you to enable different behavior for different environments.

Open `notes-api/build.gradle.kts` and change the H2 dependency so PostgreSQL is used when `-Pprod` is passed in.

[source,kotlin]
----
if (project.hasProperty("prod")) {
    runtimeOnly("org.postgresql:postgresql")
} else {
    runtimeOnly("com.h2database:h2")
}
----

At the bottom of the file, add the following code to make the `prod` profile the default when `-Pprod` is part of the `bootRun` or `bootJar` commands.

[source,kotlin]
----
val profile = if (project.hasProperty("prod")) "prod" else "dev"

tasks.bootRun {
    args("--spring.profiles.active=${profile}")
}

tasks.bootJar {
    rename("application-${profile}.properties", "application.properties")
}
----

Rename `notes-api/src/main/resources/application.properties` to `application-dev.properties` and add a URL for H2 so it will persist to disk, retaining data through restarts.

[source,properties]
----
allowed.origins=http://localhost:4200
spring.datasource.url=jdbc:h2:file:./build/h2db/notes;DB_CLOSE_DELAY=-1
----

Create a `notes-api/src/main/docker/postgresql.yml` so you can test our your `prod` profile settings.

[source,yaml]
----
version: '3'
services:
  notes-postgresql:
    image: postgres:12.1
    environment:
      - POSTGRES_USER=notes
      - POSTGRES_PASSWORD=
    ports:
      - 5432:5432
----

Create an `application-prod.properties` file in the same directory as `application-dev.properties`.
You'll override these properties with environment variables when you deploy to Heroku.

[source,properties]
.notes-api/src/main/resources/application-prod.properties
----
allowed.origins=http://localhost:4200
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:postgresql://localhost:5432/notes
spring.datasource.username=notes
spring.datasource.password=
----

The word `user` is a keyword in PostgreSQL, so you'll need to change `user` to `username` the `Note` entity.

[source,kotlin]
.notes-api/src/main/kotlin/.../DemoApplication.kt
----
data class Note(@Id @GeneratedValue var id: Long? = null,
                var title: String? = null,
                var text: String? = null,
                @JsonIgnore var username: String? = null)
----

This will cause compilation errors and you'll need to rename method names and variables to fix them.

// todo adjust diff CSS
.Click to see the diff
[%collapsible]
====
[source,diff]
----
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
index 387e332..506d761 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/DataInitializer.kt
@@ -10,7 +10,7 @@ class DataInitializer(val repository: NotesRepository) : ApplicationRunner {
     @Throws(Exception::class)
     override fun run(args: ApplicationArguments) {
         for (x in 0..1000) {
-            repository.save(Note(title = "Note ${x}", user = "matt.raible@okta.com"))
+            repository.save(Note(title = "Note ${x}", username = "matt.raible@okta.com"))
         }
         repository.findAll().forEach { println(it) }
     }
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
index 6f1292c..22a5130 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/DemoApplication.kt
@@ -26,12 +26,12 @@ fun main(args: Array<String>) {
 data class Note(@Id @GeneratedValue var id: Long? = null,
                 var title: String? = null,
                 var text: String? = null,
-                @JsonIgnore var user: String? = null)
+                @JsonIgnore var username: String? = null)

 @RepositoryRestResource
 interface NotesRepository : JpaRepository<Note, Long> {
-    fun findAllByUser(name: String, pageable: Pageable): Page<Note>
-    fun findAllByUserAndTitleContainingIgnoreCase(name: String, title: String, pageable: Pageable): Page<Note>
+    fun findAllByUsername(name: String, pageable: Pageable): Page<Note>
+    fun findAllByUsernameAndTitleContainingIgnoreCase(name: String, title: String, pageable: Pageable): Page<Note>
 }

 @Component
@@ -42,6 +42,6 @@ class AddUserToNote {
     fun handleCreate(note: Note) {
         val username: String = SecurityContextHolder.getContext().getAuthentication().name
         println("Creating note: $note with user: $username")
-        note.user = username
+        note.username = username
     }
 }
diff --git a/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt b/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
index 0f71858..670fedd 100644
--- a/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
+++ b/notes-api/src/main/kotlin/com/okta/developer/notes/UserController.kt
@@ -15,10 +15,10 @@ class UserController(val repository: NotesRepository) {
     fun notes(principal: Principal, title: String?, pageable: Pageable): Page<Note> {
         println("Fetching notes for user: ${principal.name}")
         return if (title.isNullOrEmpty()) {
-            repository.findAllByUser(principal.name, pageable)
+            repository.findAllByUsername(principal.name, pageable)
         } else {
             println("Searching for title: ${title}")
-            repository.findAllByUserAndTitleContainingIgnoreCase(principal.name, title, pageable)
+            repository.findAllByUsernameAndTitleContainingIgnoreCase(principal.name, title, pageable)
         }
     }
----
====

You won't want to pre-populate your production database with a bunch of notes, so add add a `@Profile` annotation to the top of `DataInitializer` so it only runs for the `dev` profile.

[source,kotlin]
----
import org.springframework.context.annotation.Profile
...

@Profile("dev")
class DataInitializer(val repository: NotesRepository) : ApplicationRunner {...}
----

To test your profiles, start PostgreSQL using Docker Compose.

[source,shell]
----
docker-compose -f src/main/docker/postgresql.yml up
----

In another terminal, run your Spring Boot app.

[source,shell]
----
source okta.env
./gradlew bootRun -Pprod
----

If it starts OK, confirm your Angular app can talk to it, and get ready to deploy to production!

[source,shell]
----
git commit -am "Configure environments for production"
----

== Deploy Spring Boot to Heroku

One of the easiest ways to interact with Heroku is with the https://devcenter.heroku.com/articles/heroku-cli[Heroku CLI]. Install it before proceeding with the instructions below.

Open a terminal and log in to your Heroku account.

[source,shell]
----
heroku login
----

Heroku expects you to have one Git repo per application. However, in this particular example, there's multiple apps in the same repo. This is called a **monorepo**, where many projects are stored in the same repository.

Luckily, there's a https://elements.heroku.com/buildpacks/lstoll/heroku-buildpack-monorepo[herok-buildpack-monorepo] that allows you to deploy multiple apps from the same repo.

You should already have a Heroku app that you added Okta to. Let's use that one for hosting Spring Boot. Run `heroku apps` and you'll see the one you created.

[source,shell]
----
$ heroku apps
=== matt.raible@okta.com Apps
bootiful-angular
----

You can run `heroku config -a $APP_NAME` to see your Okta variables. In my case, I'll be using `bootiful-angular` for `$APP_NAME`.

Associate your existing Git repo with the app on Heroku.

[source,shell]
----
heroku git:remote -a $APP_NAME
----

Set the `APP_BASE` config variable to point to the `notes-api` directory. While you're there, add the monorepo and Gradle buildpacks.

[source,shell]
----
heroku config:set APP_BASE=notes-api
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo
heroku buildpacks:add heroku/gradle
----

TIP: If you're using Maven, you'll want to use the `heroku/java` buildpack.

Attach a PostgreSQL database to your app.

[source,shell]
----
heroku addons:create heroku-postgresql
----

As part of this process, Heroku will automatically set configuration variables for `SPRING_DATASOURCE_URL`, `SPRING_DATASOURCE_USERNAME`, AND `SPRING_DATASOURCE_PASSWORD`. These values will override what you have in `application-prod.properties`.

By default, https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku[Heroku's Gradle support] runs `./gradlew build -x test`. Since you want it to run `./gradlew bootJar -Pprod`, you'll need to override it by setting a `GRADLE_TASK` config var.

[source,shell]
----
heroku config:set GRADLE_TASK="bootJar -Pprod"
----

The `$OKTA_*` environment variables don't have the same names as the Okta Spring Boot starter expects. This is because the Okta Heroku Add-On creates two apps: a SPA and a web app. The web app's config variables end in `_WEB`. You'll have to make some changes so those variables are used for the Okta Spring Boot starter. One way is to create a `Procfile` in the `notes-api` directory.

[source,shell]
----
web: java -Dserver.port=$PORT -Dokta.oauth2.client-id=${OKTA_OAUTH2_CLIENT_ID_WEB} -Dokta.oauth2.client-secret=${OKTA_OAUTH2_CLIENT_SECRET_WEB} -jar build/lib/*.jar
----

I think it's easier to rename the variable, so that's what I recommend. Run the following command and remove `_WEB` from the two variables that have it.

[source,shell]
----
heroku config:edit
----

Now you're ready to deploy! Take a deep breath and witness how Heroku can deploy your Spring Boot + Kotlin app with a simple `git push`.

[source,shell]
----
git push heroku master
----

When I ran this command, here's the output I received.

[source,shell]
----
remote: Compressing source files... done.
remote: Building source:
remote:
remote: -----> Monorepo app detected
remote:       Copied notes-api to root of app successfully
remote: -----> Gradle app detected
remote: -----> Spring Boot detected
remote: -----> Installing JDK 1.8... done
remote: -----> Building Gradle app...
remote: -----> executing ./gradlew bootJar -Pprod
remote:        Downloading https://services.gradle.org/distributions/gradle-6.0.1-bin.zip
remote:        ..........................................................................................
remote:        > Task :compileKotlin
remote:        > Task :compileJava NO-SOURCE
remote:        > Task :processResources
remote:        > Task :classes
remote:        > Task :bootJar
remote:
remote:        BUILD SUCCESSFUL in 1m 28s
remote:        3 actionable tasks: 3 executed
remote: -----> Discovering process types
remote:        Procfile declares types     -> (none)
remote:        Default types for buildpack -> web
remote:
remote: -----> Compressing...
remote:        Done: 91.4M
remote: -----> Launching...
remote:        Released v1
remote:        https://bootiful-angular.herokuapp.com/ deployed to Heroku
remote:
remote: Verifying deploy... done.
To https://git.heroku.com/bootiful-angular.git
   a1b10c4..6e298cf  master -> master
Execution time: 2 min. 7 s.
----

Run `heroku open` to open your app. You'll be redirected to Okta to authenticate, then back to your app. It will display a 404 error message because you have nothing mapped to `/`. Fix that by adding a `HomeController` with the following code.

[source,kotlin]
----
package com.okta.developer.notes

import org.springframework.security.core.annotation.AuthenticationPrincipal
import org.springframework.security.oauth2.core.oidc.user.OidcUser
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class HomeController {

    @GetMapping("/")
    fun hello(@AuthenticationPrincipal user: OidcUser): String {
        return "Hello, ${user.fullName}"
    }
}
----

Commit this change and deploy it to Heroku.

[source,shell]
----
git commit -am "Add HomeController"
git push heroku master
----

Now when you access the app, it should say hello.

image::{% asset_path 'blog/angular-deployment/heroku-hello.png' %}[alt=Hello, SUPER ADMIN,width=800,align=center]

== Deploy Angular to Heroku

An Angular app is composed of JavaScript, CSS, and HTML when built for production. It's extremely portable because it's just a set of static files. If you run `ng build --prod`, the production-ready files will be created in `dist/<app-name>`. In this section, you'll learn how you can use your `package.json` scripts to hook into Heroku's lifecycle and deploy with a simple `git push`.

You'll need to create another app on Heroku for the Angular frontend.

[source,shell]
----
heroku create
----

Set the `APP_BASE` config variable and add the necessary buildpacks to the app that was just created.

[source,shell]
----
APP_NAME=<app-name-from-heroku-create>
heroku config:set APP_BASE=notes -a $APP_NAME
heroku buildpacks:add https://github.com/lstoll/heroku-buildpack-monorepo -a $APP_NAME
heroku buildpacks:add heroku/nodejs -a $APP_NAME
----

Change `notes/package.json` to have a different `start` script.

[source,json]
----
"start": "http-server-spa dist/notes index.html $PORT",
----

Add a `heroku-postbuild` script to your `package.json`:

[source,json]
----
"heroku-postbuild": "ng build --prod && npm install -g http-server-spa"
----

Commit your changes, add a new Git remote for this app, and deploy!

[source,shell]
----
git commit -am "Prepare for Heroku"
git remote add angular https://git.heroku.com/<your-app-name>.git
git push angular master
----

When it finishes deploying, you can open your Angular app with:

[source,shell]
----
heroku open --remote angular
----

NOTE: If you experience any issues, you can run `heroku logs --remote angular` to see your app's log files.

You won't be able to log in to your app until you modify its Login redirect URI on Okta. Log in to your Okta dashboard (tip: you can do this from the first Heroku app you created, under the **Resources** tab). Go to **Applications** > **Heroku Created OIDC App - browser** > **General** > **Edit**. Add `https://<angular-app-on-heroku>.herokuapp.com/authorization-code/callback` to the Login URIs and `https://<angular-app-on-heroku>.herokuapp.com` to the Logout URIs.

You should be able to log in now, but you won't be able to add any notes. This is because you need to update the allowed origins in your Spring Boot app. Run the following command to add an `ALLOWED_ORIGINS` variable in your Spring Boot app.

[source,shell]
----
heroku config:set ALLOWED_ORIGINS=https://<angular-app-on-heroku>.herokuapp.com --remote heroku
----

Now you should be able to add a note. Pat yourself on the back for a job well done!

One issue you'll experience is you'll lose your data between restarts. This is because Hibernate is configured to update your database schema each time. Change it to simply validate your schema by overriding the `ddl-auto` value in `application-prod.properties`.

[source,shell]
----
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote heroku
----

=== Make Your Angular App More Secure on Heroku

You've deployed your app to Heroku, but there are a couple security issues. One is that if you access it using `http` (instead of `https`), it won't work. You'll get a blank page and an error from the Okta Angular SDK in your browser's console.

The second issue is you'll get an F when you test it using https://securityheaders.com[securityheaders.com]. Heroku has a https://blog.heroku.com/using-http-headers-to-secure-your-site[blog post on using HTTP headers to secure your site] that will help you improve your score.

Create a `notes/static.json` file with a secure headers configuration and redirect all HTTP request to HTTPS.

[source,json]
----
{
  "headers": {
    "/**": {
      "Content-Security-Policy": "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'",
      "Referrer-Policy": "no-referrer, strict-origin-when-cross-origin",
      "Strict-Transport-Security": "max-age=63072000; includeSubDomains",
      "X-Content-Type-Options": "nosniff",
      "X-Frame-Options": "DENY",
      "X-XSS-Protection": "1; mode=block",
      "Feature-Policy": "accelerometer 'none'; camera 'none'; microphone 'none'"
    }
  },
  "https_only": true,
  "root": "dist/notes/",
  "routes": {
    "/**": "index.html"
  }
}
----

For `static.json` to be read, you have to use the https://github.com/heroku/heroku-buildpack-static[Heroku static buildpack]. This buildpack is made for SPA applications, so you can revert the `scripts` section of your `package.json` back to what you had previously.

[source,json]
----
"scripts": {
  "ng": "ng",
  "start": "ng serve",
  "build": "ng build",
  "test": "ng test",
  "lint": "ng lint",
  "e2e": "ng e2e"
},
----

Commit your changes to Git, add the static buildpack, and redeploy your Angular app.

[source,shell]
----
git commit -am "Configure secure headers and static buildpack"
heroku buildpacks:add https://github.com/heroku/heroku-buildpack-static.git --remote angular
git push angular master
----

ðŸ’¥ Now you have a security report you can be proud of! ðŸ˜ƒ

image::{% asset_path 'blog/angular-deployment/heroku-headers.png' %}[alt=Security Report Summary with an A,width=800,align=center]

== Angular Deployment with `ng deploy`

In Angular CLI v8.3.0, an `ng deploy` command was introduced that allows you to automate deploying to many different cloud providers. I thought it'd be fun to try a few of these out, and see if it's possible to optimize the headers to get the same **A** rating that you were able to get with Heroku.

Below are the https://angular.io/guide/deployment[current providers and packages] supported by this command.

|===
|Hosting provider |npm package

|Firebase
|https://npmjs.org/package/@angular/fire[`@angular/fire`]

|Azure
|https://npmjs.org/package/@azure/ng-deploy[`@azure/ng-deploy`]

|Now
|https://npmjs.org/package/@zeit/ng-deploy[`@zeit/ng-deploy`]

|Netlify
|https://www.npmjs.com/package/@netlify-builder/deploy[`@netlify-builder/deploy`]

|GitHub pages
|https://npmjs.org/package/angular-cli-ghpages[`angular-cli-ghpages`]

|NPM
|https://npmjs.org/package/ngx-deploy-npm[`ngx-deploy-npm`]

|AWS S3
|https://www.npmjs.com/package/@jefiozie/ngx-aws-deploy[`@jefiozie/ngx-aws-deploy`]
|===

In the following section, I'll show you how to deploy to a few that piqued my interest.

=== Angular Deployment to Firebase

Create a `firebase` branch so you can make changes without affecting the work you've done for Heroku deployments.

[source,shell]
----
git checkout -b firebase
----

Install the `@angular/fire` package.

[source,shell]
----
cd notes
ng add @angular/fire
----

When I first ran this command, I received the following output:

[source,shell]
----
UPDATE package.json (1659 bytes)
âœ” Packages installed successfully.
âœ– Preparing the list of your Firebase projects
Failed to list Firebase projects. See firebase-debug.log for more info.
----

According to https://github.com/angular/angularfire/blob/master/docs/deploy/getting-started.md[@angular/fire's documentation], it's supposed to open a web browser and guide you through the authentication flow. I'm guessing it assumes you have the https://firebase.google.com/docs/cli[Firebase CLI] installed. I installed it:

[source,shell]
----
curl -sL https://firebase.tools | bash
----

NOTE: And tried running `ng add @angular/fire` again. It failed again, so I ran `firebase logout` and tried again. This time it worked, but when it prompted me for project, the list was empty and I was unable to go further. I tried creating a new project from the command line using `firebase init`, but when that failed, I found it easier to use a web browser.

Open a browser and go to https://firebase.google.com/[firebase.google.com]. Log in to your account, go to the console, and create a new project.

Run `ng add @angular/fire` again and your new project should show up in the list. Select it to continue.

[source,shell]
----
? Please select a project: ng-notes-1337 (ng-notes-1337)
CREATE firebase.json (300 bytes)
CREATE .firebaserc (133 bytes)
UPDATE angular.json (3755 bytes)
----

Now you can run `ng deploy` and everything should work.

You'll need to add the project's URL as an allowed origin in your Spring Boot app on Heroku.
Copy the printed `Hosting URL` value and run the following command.

[source,shell]
----
heroku config:edit --remote heroku
----

Add the new URL after your existing Heroku one, separating them with a comma. For example:

[source,shell]
----
ALLOWED_ORIGINS='https://stark-lake-39546.herokuapp.com,https://ng-notes-1337.web.app'
----

You'll also need to modify your Okta SPA app to add your Firebase URL as a Login redirect URI and Logout redirect URI. For mine, I added:

* Login redirect URI: `\https://ng-notes-1337.web.app/authorization-code/callback`
* Logout redirect URI: `\https://ng-notes-1337.web.app`

Open your Firebase URL in your browser, log in, and you should be able to see the note you added on Heroku.

=== Improve Security Headers for Firebase

If you test your new Firebase site on https://securityheaders.com/[securityheaders.com], you'll get a D. Luckily, you can https://firebase.google.com/docs/hosting/full-config#headers[configure headers] in your `firebase.json` file. Edit this file and a `headers` key like the following:

[source,json]
----
"headers": [ {
  "source": "/**",
  "headers": [
    {
      "key": "Content-Security-Policy",
      "value": "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'"
    },
    {
      "key": "Referrer-Policy",
      "value": "no-referrer, strict-origin-when-cross-origin"
    },
    {
      "key": "X-Content-Type-Options",
      "value": "nosniff"
    },
    {
      "key": "X-Frame-Options",
      "value": "DENY"
    },
    {
      "key": "X-XSS-Protection",
      "value": "1; mode=block"
    },
    {
      "key": "Feature-Policy",
      "value": "accelerometer 'none'; camera 'none'; microphone 'none'"
    }
  ]
} ]
----

NOTE: You don't need to include a `Strict-Transport-Security` header because Firebase includes it by default.

Run `ng deploy` and you should get an **A** now!

image::{% asset_path 'blog/angular-deployment/firebase-headers.png' %}[alt=Firebase app score from securityheaders.com,width=800,align=center]

Commit your changes to your `firebase` branch.

[source,shell]
----
git commit -am "Add Firebase deployment"
----

=== Angular Deployment to Netlify

Netlify is a hosting provider for static sites that I've enjoyed using in the past. They offer continuous integration, HTML forms, AWS Lambda functions, and CMS functionality. I wrote about Netlify in link:/blog/2020/02/18/gatsby-react-netlify[Build a Secure Blog with Gatsby, React, and Netlify].

Check out your `master` branch and create a new `netlify` one.

[source,shell]
----
git checkout master
git checkout -b netlify
----

Before running the command to add Netlify support, you'll need to https://app.netlify.com/signup[create a Netlify account]. Once you're signed in, create a new site. Netlify makes it easy to connect a site via Git, but since I want to demonstrate `ng deploy`, you'll need to create a temporary directory with an `index.html` file in it. I put "Hello, World" in the HTML file, then dragged the directory into my browser window.

image::{% asset_path 'blog/angular-deployment/netlify-create-site.png' %}[alt=Netlify create site,width=650,align=center]

Click on **Site Settings** to copy your **API ID** to a text editor. You'll also need a personal access token. To create one, click on your avatar in the top right > **User settings** > **Applications** and click **New access token**. Copy the generated token to your text editor.

Run the command below to add Netlify deployment support.

[source,shell]
----
ng add @netlify-builder/deploy
----

Copy and paste your API ID and personal access token when prompted, then run `ng deploy` to deploy your site.

Update your Spring Boot app on Heroku to allow your Netlify app URL:

[source,shell]
----
heroku config:edit --remote heroku
----

Make sure to append the URL to your existing ones, separating them with a comma.

[source,shell]
----
ALLOWED_ORIGINS='https://stark-lake-39546.herokuapp.com,https://ng-notes-1337.web.app,https://relaxed-brown-0b81d8.netlify.app'
----

You'll also need to update your Okta app to whitelist the URL as a redirect.

If you try to login, you'll get a `Page Not Found` error when Okta tried to redirect back to your app. This happens because Netlify doesn't know your app is a SPA that manages its own routes. To fix this, create a `_redirects` file in the `notes/src` directory with the following contents.

[source,shell]
----
/*    /index.html   200
----

TIP: You can learn more about https://docs.netlify.com/routing/redirects/rewrites-proxies/#history-pushstate-and-single-page-apps[configuring Netlify for SPAs in their documentation].

Then, modify `angular.json` to include this file in its assets.

[source,json]
----
"assets": [
  "src/_redirects",
  "src/favicon.ico",
  "src/assets"
],
----

Run `ng deploy` again and you should be able to log in successfully.

=== Improve Security Headers for Netlify

If you test your new Firebase site on https://securityheaders.com/[securityheaders.com], you'll get a D. Netlify allows you to add https://docs.netlify.com/routing/headers/[custom headers] to improve your score.

Create a `src/_headers` file with the following contents.

[source,text]
----
/*
  Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'
  Referrer-Policy: no-referrer, strict-origin-when-cross-origin
  X-Content-Type-Options: nosniff
  X-Frame-Options: DENY
  X-XSS-Protection: 1; mode=block
  Feature-Policy: accelerometer 'none'; camera 'none'; microphone 'none'
----

NOTE: You don't need to include a `Strict-Transport-Security` header because Netlify includes one by default.

Modify `angular.json` to include this file in its assets.

[source,json]
----
"assets": [
  "src/_headers",
  "src/_redirects",
  "src/favicon.ico",
  "src/assets"
],
----

Run `ng deploy` and you should get an **A** now!

image::{% asset_path 'blog/angular-deployment/netlify-headers.png' %}[alt=Netlify score from securityheaders.com,width=800,align=center]

Commit your changes to the `netlify` branch.

[source,shell]
----
git commit -am "Add Netlify deployment"
----

=== Angular Deployment to AWS S3

Amazon Simple Storage Service (Amazon S3) is an object storage service that is a popular option for hosting static sites.

Check out your `master` branch and create a new `aws` one.

[source,shell]
----
git checkout master
git checkout -b aws
----

Before running the command to add S3 deployment support, you'll need a few things:

* An S3 Bucket
* An AWS Region Name
* A Secret Access Key
* An Access Key ID

to https://portal.aws.amazon.com/billing/signup[create an AWS account]. After creating an account, go to the https://s3.console.aws.amazon.com/[Amazon S3 console]. Click **Create Bucket** and give it a name you'll remember. Use the default region selected for you and click **Create Bucket**.

To create the secret access key, go to your https://console.aws.amazon.com/iam/home?nc2=h_m_sc#/security_credentials[security credentials page]. Expand the **Access keys** section, and then **Create New Access Key**. Click **Show Access Key** and copy the values into a text editor.

TIP: If you have trouble creating a secret access key, see https://aws.amazon.com/blogs/security/how-to-find-update-access-keys-password-mfa-aws-management-console/[this blog post].

Add the `@jefiozie/ngx-aws-deploy` package to deploy to S3:

[source,shell]
----
ng add @jefiozie/ngx-aws-deploy
----

When prompted, enter your region, bucket name, access key, and access key ID. When prompted for the folder, leave it blank.

CAUTION: This process writes these raw values to your `angular.json`. For more security, use environment variables: `NG_DEPLOY_AWS_ACCESS_KEY_ID`, `NG_DEPLOY_AWS_SECRET_ACCESS_KEY`, `NG_DEPLOY_AWS_BUCKET` and `NG_DEPLOY_AWS_REGION`.

After deploying your Angular app, you need to https://docs.aws.amazon.com/AmazonS3/latest/user-guide/static-website-hosting.html[configure S3 for static website hosting]. Go to your bucket > **Properties** > **Static website hosting**. Take node of the endpoint URL at the top of the card, you'll need this in a minute.

Type `index.html` for the index and error document and click **Save**.

image::{% asset_path 'blog/angular-deployment/aws-static-website.png' %}[alt=AWS static website,width=550,align=center]

By default, Amazon S3 blocks public access to your buckets. Go to the **Permissions** tab. Click the **Edit** button, clear **Block all public access**, and click **Save**.

The last step you need to do to make it public is add a bucket policy. Go to **Permissions** > **Bucket Policy** and paste the following into the editor, replacing `{your-bucket-name}` with your bucket's name.

[source,json]
----
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "PublicReadGetObject",
            "Effect": "Allow",
            "Principal": "*",
            "Action": [
                "s3:GetObject"
            ],
            "Resource": [
                "arn:aws:s3:::{your-bucket-name}/*"
            ]
        }
    ]
}
----

At this point, you could navigate to https://<bucket-name>.s3.amazonaws.com/index.html in your browser, and the application will load. However, there's no HTTP to HTTPS redirect or resolution of `index.html` by default. You can use https://aws.amazon.com/premiumsupport/knowledge-center/cloudfront-https-requests-s3/[use CloudFront to solve these issues].

Open the https://console.aws.amazon.com/cloudfront/[CloudFront console] and choose **Create Distribution**. Under the Web section, click the **Get Started** button.
Click in the **Origin Domain Name** field and select your S3 bucket.

Set the **Viewer Protocol Policy** to `Redirect HTTP to HTTPS`, allow all HTTP methods, and enter `index.html` as the **Default Root Object**. Scroll to the bottom and click **Create Distribution**. When the Status column changes from `In Progress` to `Deployed`, navigate to the domain name in your browser.

NOTE: After you create your distribution, it can take 20 minutes for it to deploy.

Once your distribution is deployed, update your Spring Boot app on Heroku to allow your CloudFront URL:

[source,shell]
----
heroku config:edit --remote heroku
----

Make sure to append the URL to your existing ones, separating them with a comma.

[source,shell]
----
ALLOWED_ORIGINS='https://stark-lake-39546.herokuapp.com,https://ng-notes-1337.web.app,https://relaxed-brown-0b81d8.netlify.app,https://d2kytj28ukuxfr.cloudfront.net'
----

Update your Okta SPA app to whitelist the URL as a redirect too.

If you try to log in, you'll get a 403 when redirecting back to the site. To fix this, edit your distribution > **Error pages**. Create two custom error responses for `404` and `403`. Return a path of `/index.html` and a `200: OK` response code.

Now you should be able to authenticate to your Angular app on AWS successfully!

=== Improve Security Headers for AWS CloudFront + S3

If you test your new CloudFront + S3 site on https://securityheaders.com/[securityheaders.com], you'll get an F. To solve this, you can use https://aws.amazon.com/blogs/networking-and-content-delivery/adding-http-security-headers-using-lambdaedge-and-amazon-cloudfront/[Lambda@Edge to add security headers].

Go to the https://us-west-2.console.aws.amazon.com/lambda/home[Lambda Console] and select the `US-East-1 N` region from a drop-down list in the top right. Click **Create Function** to create a new function.

Choose **Author from scratch** and name it `securityHeaders`. Under Permissions, select **Create a new role from AWS Policy templates**. Name the role `securityHeaders-role` and select `Basic Lambda@Edge permissions (for CloudFront trigger)`. Click **Create function**.

In the Function code section, set `index.js` to have the following JavaScript.

[source,js]
----
exports.handler = (event, context, callback) => {

  // get response
  const response = event.Records[0].cf.response;
  const headers = response.headers;

  // set headers
  headers['content-security-policy'] = [{key: 'Content-Security-Policy', value: "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'"}];
  headers['referrer-policy'] = [{key: 'Referrer-Policy', value: 'no-referrer, strict-origin-when-cross-origin'}];
  headers['strict-transport-security'] = [{key: 'Strict-Transport-Security', value: 'max-age=63072000; includeSubdomains'}];
  headers['x-content-type-options'] = [{key: 'X-Content-Type-Options', value: 'nosniff'}];
  headers['x-frame-options'] = [{key: 'X-Frame-Options', value: 'DENY'}];
  headers['x-xss-protection'] = [{key: 'X-XSS-Protection', value: '1; mode=block'}];
  headers['feature-policy'] = [{key: 'Feature-Policy', value: "accelerometer 'none'; camera 'none'; microphone 'none'"}];

  // return modified response
  callback(null, response);
};
----

Click **Save** and add a trigger. Select **CloudFront** and **Deploy to Lambda@Edge**. For the distribution, use the ID of your CloudFront distribution. Set the event to be **Origin response**. Select the "I acknowledge..." checkbox and click **Deploy**.

Go back to your CloudFront Console and wait for the deploy to complete.

Try your CloudFront domain again on https://securityheaders.com[securityheaders.com]. You should get an **A** this time.

image::{% asset_path 'blog/angular-deployment/aws-headers.png' %}[alt=AWS score from securityheaders.com,width=800,align=center]

_Phew! AWS certainly doesn't make things easy._

Commit your changes to the `aws` branch.

[source,shell]
----
git commit -am "Add AWS S3 deployment"
----

NOTE: If you committed the changes in your `angular.json` file, you should delete your access key in **My Account** > **Security Credentials**.

== Create a Docker Container for Your Angular App

**Prerequisites:**

* https://docs.docker.com/install/[Docker]
* https://nodejs.org/[Node.js] 12+
* https://adoptopenjdk.net/[Java] 8+

Create a `Dockerfile` that uses the latest version of Node and nginx as a web server.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
COPY nginx.config /etc/nginx/conf.d/default.conf
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

[NOTE]
====
When I was working on this file, I found it handy to comment out the `RUN ng build --prod` line and use the following instead.

[source,shell]
----
RUN mkdir -p dist/notes
RUN echo "Hello, World" > dist/notes/index.html
----

This allows you to skip the lengthy Angular build process.
====

You'll need to create the `nginx.config` file to make nginx SPA-aware.

[source,config]
.notes/nginx.config
----
server {
    listen   80;
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri /index.html;
    }
}
----

Make sure your Docker daemon is running with `docker ps`. Then run the following command to build your Docker image. The `ng-notes` value can be whatever you want to name your image.

[source,shell]
----
docker build -t ng-notes .
----

If it builds successfully, you'll see messages like the following:

[source,shell]
----
Successfully built 382b9cd7d345
Successfully tagged ng-notes:latest
----

You can run it locally on port 4200 using the `docker run` command.

[source,shell]
----
docker run -p 4200:80 ng-notes
----

[NOTE]
====
If you find these `docker` commands hard to remember, you can add a couple scripts to your `package.json` file.

[source,json]
----
"build-docker": "docker build -t ng-notes .",
"docker": "docker run -p 4200:80 ng-notes"
----
====

Since this runs the production build, you'll need to add `\http://localhost:4200` as an allowed origin in your Spring Boot app on Heroku. Run the following command and add it to the end of the existing values.

[source,shell]
----
heroku config:edit --remote heroku
----

TIP: One advantage of doing this is you can run your local Angular app against your production backend. I've found this very useful when debugging and fixing UI issues caused by production data.

To publish your image so you can deploy it, you can use Docker Hub. If you don't already have a Docker Hub account, you can https://hub.docker.com/signup[create one].

Once you have an account, log in and push your image.

[source,shell]
----
docker login
docker image tag ng-notes mraible/ng-notes
docker push mraible/ng-notes
----

This will tag it as `latest` by default. If you want to tag and push a particular version, you can do:

[source,shell]
----
docker image tag ng-notes mraible/ng-notes:1.0
docker push mraible/ng-notes
----

IMPORTANT: Your image will be public by default. If you navigate to your image on Docker Hub in a browser, you can go to its **Settings** tab and make it private.

== Docker on Heroku

Heroku has a https://devcenter.heroku.com/articles/container-registry-and-runtime[couple slick features when it comes to Docker images]. If your project has a `Dockerfile`, you can deploy your app directly using the Heroku Container Registry.

First, log in to the Container Registry.

[source,shell]
----
heroku container:login
----

Then, create a new app.

[source,shell]
----
heroku create
----

Add the Git URL as a new remote to your app.

[source,shell]
----
git remote add docker https://git.heroku.com/<your-app-name>.git
----

You'll need to update `nginx.config` so it reads from a `$PORT` environment variable if it's set, otherwise default it to 80. You can use https://michalzalecki.com/nginx-listen-on-port-docker/[`envsubst` to do this at runtime]. However, the default `envsubst` doesn't allow default variables. The good news is https://github.com/a8m/envsubst[a8m/envsubst] on GitHub does!

Replace your `nginx.config` with the following configuration that defaults to 80 and escapes the `$uri` variable so it's not replaced with a blank value.

[source,config]
.notes/nginx.config
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }
}
----

You'll also need to update your `Dockerfile` so it uses the aforementioned `envsubstr`.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
RUN apk --no-cache add curl
RUN curl -L https://github.com/a8m/envsubst/releases/download/v1.1.0/envsubst-`uname -s`-`uname -m` -o envsubst && \
    chmod +x envsubst && \
    mv envsubst /usr/local/bin
COPY ./nginx.config /etc/nginx/nginx.template
CMD ["/bin/sh", "-c", "envsubst < /etc/nginx/nginx.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"]
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

Then, push your Docker image to Heroku's Container Registry.

[source,shell]
----
heroku container:push web --remote docker
----

Once the push process has completed, release the image of your app:

[source,shell]
----
heroku container:release web --remote docker
----

And open the app in your browser:

[source,shell]
----
heroku open --remote docker
----

You'll need to add your app's URI in Okta and as an allowed origin for the backend with `heroku config:edit`.

See Heroku's https://devcenter.heroku.com/articles/container-registry-and-runtime[Container Registry & Runtime (Docker Deploys)] for more information.

=== Improve Security Headers for Nginx in Docker

If you test your new Nginx in Docker site on https://securityheaders.com/[securityheaders.com], you'll get an F. To solve this, you can modify your `nginx.config` to add security headers.

[source,config]
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'";
    add_header Referrer-Policy "no-referrer, strict-origin-when-cross-origin";
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains";
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
    add_header Feature-Policy "accelerometer 'none'; camera 'none'; microphone 'none'";
}
----

After updating this file, run the following commands:

[source,shell]
----
heroku container:push web --remote docker
heroku container:release web --remote docker
----

Now you should get an **A** !

image::{% asset_path 'blog/angular-deployment/nginx-headers.png' %}[alt=Nginx in Docker score from securityheaders.com,width=800,align=center]

== Combine Your Angular + Spring Boot App into a Single JAR

In the previous sections, you learned how to deploy your Angular and Spring Boot apps separately. Now I'll show you how to combine them into a single JAR for production. You'll still be able to run them independently in development, but deploying them to production will be easier because you won't have to worry about CORS. I'll also convert the OAuth flows so they all happen server-side, which is more secure because the access token won't be stored in the browser.

TIP: Most client-side OAuth libraries keep access tokens in local storage. However, there is a https://gitlab.com/jimdigriz/oauth2-worker[oauth2-worker] project that allows you to store them in a web worker.

Check out your `master` branch and create a new `jar` one.

[source,shell]
----
git checkout master
git checkout -b jar
----

https://developer.okta.com/blog/2020/03/27/spring-oidc-logout-options

// Deploy JAR to CF


== Package Angular + Spring Boot with Docker

[source,kotlin]
----
plugins {
    ...
    id("com.google.cloud.tools.jib") version "2.2.0"
}
----

java -jar build/libs/*.jar

tasks.jibDockerBuild {
    dependsOn("bootJar")
}

./gradlew jibDockerBuild -Pprod --image=bootiful-angular

docker run --publish=8080:8080 bootiful-angular

Copy `notes-api/okta.env` to `src/main/docker/.env`.

Change it to:

[source,shell]
----
OKTA_OAUTH2_ISSUER=https://dev-210914.okta.com/oauth2/default
OKTA_OAUTH2_CLIENT_ID=0oaa7psy3dzvqsPjk4x6
OKTA_OAUTH2_CLIENT_SECRET=FJcSFpTC6NHENPPtb7RRWk6sGwPzYa7d7xPcsWsi
----

./gradlew jibDockerBuild -Pprod
docker run --publish=8080:8080 bootiful-angular


cd src/main/docker
docker-compose -f src/main/docker/app.yml up

// todo: warn about using `build` vs. `bootJar` and tests

Deploy to Docker hub by renaming task from jibDockerBuild to jib and running

 ./gradlew jib -Pprod

// Heroku Docker

[source,shell]
----
heroku create
git remote add jib https://git.heroku.com/enigmatic-woodland-19325.git

// attach old or create PostreSQL and Okta
heroku addons:create heroku-postgresql --remote jib

heroku config:get DATABASE_URL --remote jib
heroku config:set SPRING_DATASOURCE_URL=<value-after-@-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_USERNAME=<username-value-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_PASSWORD=<password-value-from-last-command> --remote jib
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote jib

// screenshot + commands to match

heroku addons:create okta --remote jib


// See config with
heroku config --remote jib

Remove _WEB from Okta

docker tag hub.docker.com/mraible/bootiful-angular registry.heroku.com/enigmatic-woodland-19325/web
docker push registry.heroku.com/enigmatic-woodland-19325/web
heroku container:release web --remote jib


Add server.port=${PORT:8080} to application-prod.properties and run  ./gradlew jibDockerBuild -Pprod
----

// CF Docker https://docs.cloudfoundry.org/adminguide/docker.html
// Google Cloud and Kubernetes OR KNative

https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#headers


        http.headers()
                .contentSecurityPolicy("script-src 'self'; report-to /csp-report-endpoint/")
                .and()
                .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.SAME_ORIGIN)
                .and()
                .featurePolicy("accelerometer 'none'; camera 'none'; microphone 'none'")

// todo: try logout


./gradlew jib

or

docker image tag bootiful-angular mraible/bootiful-angular
docker push mraible/bootiful-angular

KNative: https://docs.google.com/document/d/1SLEga2V6N_UaxPcEhDku7gViRJflmtFGljgz-OLUNUQ/edit?ts=5eb1f757

https://skaffold.dev/

https://spring.io/blog/2020/01/27/creating-docker-images-with-spring-boot-2-3-0-m1

== Learn More About Angular and Spring Boot

https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku
https://devcenter.heroku.com/articles/deploying-executable-jar-files
https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku

https://developer.okta.com/blog/2018/07/03/deploy-vue-app-aws
https://developer.okta.com/blog/2018/07/31/use-aws-cloudformation-to-automate-static-site-deployment-with-s3
