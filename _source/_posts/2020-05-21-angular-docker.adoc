---
layout: blog_post
title: "Angular Docker"
author: matt-raible
by: advocate
communities: [java,javascript,devops]
description: "Use Docker to build & deploy an Angular app! Includes how to combine Angular + Spring Boot into a JAR, dockerize it, and deploy to KNative + Cloud Foundry."
tags: [angular, docker, heroku, jarnotwar, spring boot, knative, cloudfoundry, buildpacks]
tweets:
- "A Quick Guide to #Docker with #Angular and Spring Boot. ðŸ‘‡"
- "Angular + Spring Boot + Docker: learn how to create an image with a Dockerfile, with #jib, and using @buildpacks_io!"
- "Combine @angular + @springboot in a single JAR, the use Jib to build a Docker image."
image:
type: conversion
---
:toc: macro
:page-liquid:

Building modern apps with Angular and Spring Boot is a common practice these days. In fact, if I use Google's Keyword Planner to look up popular search terms, it's one of the most popular combinations. The results in the list below are average monthly searches and not limited by location.

- `angular spring boot`: 3600
- `react spring boot`: 1000
- `angular express`: 1900
- `angular aspnet`: 210
- `angular flask`: 320
- `angular symfony`: 390

This tutorial is the fourth and final in a series on Angular and Spring Boot in 2020. In the first one, I showed how to create a secure notes app with Angular and Spring Boot + Kotlin. The second showed how to add Bootstrap for CSS and create a sortable, searchable, and pageable data table. The third showed you how to deploy your apps separate to Heroku. It also showed how it's possible to use `ng deploy` to deploy to Firebase, Netlify, and AWS.

1. link:/blog/2020/01/06/crud-angular-9-spring-boot-2[Build a CRUD App with Angular 9 and Spring Boot 2.2]
2. link:/blog/2020/03/02/angular-bootstrap[Build Beautiful Angular Apps with Bootstrap]
3. //todo

Today, I'll show you how to use Docker to create an image for your Angular app and deploy it to Heroku. Then, I'll show how to combine Angular and Spring Boot into the same JAR artifact for deployment. You'll learn how to Dockerize the combined apps using Jib and Cloud Native Buildpacks. Finally, I'll show you how to deploy your Docker image to Heroku, KNative on Google Cloud, and Cloud Foundry.

I'd like to thank Benoit Sautel for his help with Gradle + Kotlin, Ray Tsang for his help with Jib, James Ward for his help with KNative, and Josh Long his assistance with Docker + Cloud Foundry.

Docker is the most popular way to build and share containers. _Dockerizing_ involves packaging your app, and you can include web servers to serve up your app. This is important when containerizing an Angular app because its artifacts are just JavaScript, CSS, and HTML. That is, the production app is static files that will need to be served up by some sort of webserver. As an added bonus, you can configure the webserver to send security headers that make your app more secure.

toc::[]

== Create an Angular + Spring Boot App

To begin, clone the GitHub repo from the previous tutorial in this series.

// todo: remove jar and docker branches from angular-deployment

[source,shell]
----
git clone https://github.com/oktadeveloper/okta-angular-deployment-example.git \
  angular-spring-boot-docker
----

**Prerequisites:**

* https://docs.docker.com/install/[Docker]
* https://nodejs.org/[Node.js] 12+
* https://adoptopenjdk.net/[Java] 8+
* An https://developer.okta.com/signup/[Okta Developer Account]

=== Secure Your Angular + Spring Boot App with OpenID Connect

OAuth 2.0 was finalized in 2012 and has since become the industry-standard protocol for authorization. In 2014, OpenID Connect (OIDC) extended OAuth, adding federated identity to delegated authorization. Together, these two layers offer a standard specification that developers can write code against in a way that will work across multiple identity providers.

To begin adding OIDC to Angular and Spring Boot, you'll need to https://signup.heroku.com/login[create a Heroku account]. If you already have a Heroku account, https://id.heroku.com/login[log in to it]. Once you're logged in, create a new app. I named mine `bootiful-angular`.

image::{% asset_path 'blog/angular-deployment/heroku-create-app.png' %}[alt=Create Heroku app,width=700,align=center]

After creating your app, click on the **Resources** tab and add the **Okta** add-on.

image::{% asset_path 'blog/angular-deployment/okta-add-on.png' %}[alt=Okta Add-On,width=475,align=center]

CAUTION: If you haven't entered a credit card for your Heroku account, you will get an error. This is because Heroku requires you to have a credit card on file to use any of their add-ons, even for free ones. This is part of Heroku's assurance to guard against misuse (real person, real credit card, etc.). I think this is a good security practice. Add a credit card to continue.

Click **Provision** and wait 20-30 seconds while your Okta account is created and OIDC apps are registered. Now go to your app's **Settings** tab and click the **Reveal Config Vars** button. The variables displayed are the environment variables you can use to configure both Angular and Spring Boot for OIDC authentication.

image::{% asset_path 'blog/angular-deployment/heroku-config-vars.png' %}[alt=Okta Add-On,width=800,align=center]

Create an `okta.env` file in the `angular-spring-boot-docker/notes-api` directory and copy the variable values into it, where `$OKTA_*` is the value from Heroku.

[source,shell]
----
export OKTA_OAUTH2_ISSUER=$OKTA_OAUTH2_ISSUER
export OKTA_OAUTH2_CLIENT_ID=$OKTA_OAUTH2_CLIENT_ID_WEB
export OKTA_OAUTH2_CLIENT_SECRET=$OKTA_OAUTH2_CLIENT_SECRET_WEB
----

[NOTE]
====
If you're on Windows without https://docs.microsoft.com/en-us/windows/wsl/install-win10[Windows Subsystem for Linux] installed, create an `okta.bat` file and use `SET` instead of `export`.
====

Start your Spring Boot app by navigating to the `notes-api` directory, sourcing this file, and starting your app.

[source,shell]
----
source okta.env
./gradlew bootRun
----

For Windows users, the commands will be:

[source,shell]
----
okta.bat
gradlew
----

Next, configure Angular for OIDC authentication by modifying its `auth-routing.module.ts` to use the generated issuer and client ID.

[source,typescript]
.notes/src/app/auth-routing.module.ts
----
const oktaConfig = {
 issuer: '$OKTA_OAUTH2_ISSUER',
 redirectUri: window.location.origin + '/callback',
 clientId: '$OKTA_OAUTH2_CLIENT_ID_SPA',
 pkce: true
};
----

By default, Heroku registers a SPA app on the same port (`8080`) as a web app. This means you need to log in to your Okta dashboard and add a new redirect URI for local development. Luckily, Heroku makes this easy to do. Go to **Resources** and click on the **okta** addon. This will log you into your Okta dashboard. Navigate to **Applications** > **Heroku Created OIDC App - browser** > **General** > **Edit**.

Add `http://localhost:4200/callback` as a Login redirect URI and `http://localhost:4200` as a Logout redirect URI. You'll also need to add `http://localhost:4200` as a trusted origin in **API** > **Trusted Origins**.

Install your Angular app's dependencies and start it.

[source,shell]
----
npm i
ng serve
----

Open `http://localhost:4200` in your browser.

image::{% asset_path 'blog/angular-deployment/angular-home.png' %}[alt=Angular Home,width=800,align=center]

Click the **Login** button in the top right corner. You should be logged in without seeing a login form because you're already logged in to Okta. If you want to see the full authentication flow, log out, or try it in a private window. You can use the `$OKTA_ADMIN_EMAIL` and `$OKTA_ADMIN_PASSWORD` from your Heroku config variables for credentials. Create a note to make sure everything works.

Commit your progress to Git from the top-level `angular-spring-boot-docker` directory.

[source,shell]
----
git commit -am "Add Okta OIDC Configuration"
----

== Create a Docker Container for Your Angular App

Create a `Dockerfile` that uses the latest version of Node and nginx as a web server.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
COPY nginx.config /etc/nginx/conf.d/default.conf
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

[NOTE]
====
When I was working on this file, I found it handy to comment out the `RUN ng build --prod` line and use the following instead.

[source,shell]
----
RUN mkdir -p dist/notes
RUN echo "Hello, World" > dist/notes/index.html
----

This allows you to skip the lengthy Angular build process.
====

You'll need to create the `nginx.config` file to make nginx SPA-aware.

[source,config]
.notes/nginx.config
----
server {
    listen   80;
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri /index.html;
    }
}
----

Make sure your Docker daemon is running with `docker ps`. Then run the following command to build your Docker image. The `ng-notes` value can be whatever you want to name your image.

[source,shell]
----
docker build -t ng-notes .
----

If it builds successfully, you'll see messages like the following:

[source,shell]
----
Successfully built 382b9cd7d345
Successfully tagged ng-notes:latest
----

You can run it locally on port 4200 using the `docker run` command.

[source,shell]
----
docker run -p 4200:80 ng-notes
----

[NOTE]
====
If you find these `docker` commands hard to remember, you can add a couple scripts to your `package.json` file.

[source,json]
----
"build-docker": "docker build -t ng-notes .",
"docker": "docker run -p 4200:80 ng-notes"
----
====

Since this runs the production build, you'll need to add `\http://localhost:4200` as an allowed origin in your Spring Boot app on Heroku. Run the following command and add it to the end of the existing values.

[source,shell]
----
heroku config:edit --remote heroku
----

TIP: One advantage of doing this is you can run your local Angular app against your production backend. I've found this very useful when debugging and fixing UI issues caused by production data.

To publish your image so you can deploy it, you can use Docker Hub. If you don't already have a Docker Hub account, you can https://hub.docker.com/signup[create one].

Once you have an account, log in and push your image.

[source,shell]
----
docker login
docker image tag ng-notes mraible/ng-notes
docker push mraible/ng-notes
----

This will tag it as `latest` by default. If you want to tag and push a particular version, you can do:

[source,shell]
----
docker image tag ng-notes mraible/ng-notes:1.0
docker push mraible/ng-notes
----

IMPORTANT: Your image will be public by default. If you navigate to your image on Docker Hub in a browser, you can go to its **Settings** tab and make it private.

== Docker on Heroku

Heroku has a https://devcenter.heroku.com/articles/container-registry-and-runtime[couple slick features when it comes to Docker images]. If your project has a `Dockerfile`, you can deploy your app directly using the Heroku Container Registry.

First, log in to the Container Registry.

[source,shell]
----
heroku container:login
----

Then, create a new app.

[source,shell]
----
heroku create
----

Add the Git URL as a new remote to your app.

[source,shell]
----
git remote add docker https://git.heroku.com/<your-app-name>.git
----

You'll need to update `nginx.config` so it reads from a `$PORT` environment variable if it's set, otherwise default it to 80. You can use https://michalzalecki.com/nginx-listen-on-port-docker/[`envsubst` to do this at runtime]. However, the default `envsubst` doesn't allow default variables. The good news is https://github.com/a8m/envsubst[a8m/envsubst] on GitHub does!

Replace your `nginx.config` with the following configuration that defaults to 80 and escapes the `$uri` variable so it's not replaced with a blank value.

[source,config]
.notes/nginx.config
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }
}
----

You'll also need to update your `Dockerfile` so it uses the aforementioned `envsubstr`.

[source,docker]
.notes/Dockerfile
----
FROM node:14.1-alpine AS builder

WORKDIR /opt/web
COPY package.json package-lock.json ./
RUN npm install

ENV PATH="./node_modules/.bin:$PATH"

COPY . ./
RUN ng build --prod

FROM nginx:1.17-alpine
RUN apk --no-cache add curl
RUN curl -L https://github.com/a8m/envsubst/releases/download/v1.1.0/envsubst-`uname -s`-`uname -m` -o envsubst && \
    chmod +x envsubst && \
    mv envsubst /usr/local/bin
COPY ./nginx.config /etc/nginx/nginx.template
CMD ["/bin/sh", "-c", "envsubst < /etc/nginx/nginx.template > /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'"]
COPY --from=builder /opt/web/dist/notes /usr/share/nginx/html
----

Then, push your Docker image to Heroku's Container Registry.

[source,shell]
----
heroku container:push web --remote docker
----

Once the push process has completed, release the image of your app:

[source,shell]
----
heroku container:release web --remote docker
----

And open the app in your browser:

[source,shell]
----
heroku open --remote docker
----

You'll need to add your app's URI in Okta and as an allowed origin for the backend with `heroku config:edit`.

See Heroku's https://devcenter.heroku.com/articles/container-registry-and-runtime[Container Registry & Runtime (Docker Deploys)] for more information.

=== Improve Security Headers for Nginx in Docker

If you test your new Nginx in Docker site on https://securityheaders.com/[securityheaders.com], you'll get an F. To solve this, you can modify your `nginx.config` to add security headers.

[source,config]
----
server {
    listen       ${PORT:-80};
    server_name  _;

    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $$uri /index.html;
    }

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; frame-ancestors 'none'";
    add_header Referrer-Policy "no-referrer, strict-origin-when-cross-origin";
    add_header Strict-Transport-Security "max-age=63072000; includeSubDomains";
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;
    add_header X-XSS-Protection "1; mode=block";
    add_header Feature-Policy "accelerometer 'none'; camera 'none'; microphone 'none'";
}
----

After updating this file, run the following commands:

[source,shell]
----
heroku container:push web --remote docker
heroku container:release web --remote docker
----

Now you should get an **A** !

image::{% asset_path 'blog/angular-deployment/nginx-headers.png' %}[alt=Nginx in Docker score from securityheaders.com,width=800,align=center]

== Combine Your Angular + Spring Boot App into a Single JAR

In the previous sections, you learned how to deploy your Angular and Spring Boot apps separately. Now I'll show you how to combine them into a single JAR for production. You'll still be able to run them independently in development, but deploying them to production will be easier because you won't have to worry about CORS. I'll also convert the OAuth flows so they all happen server-side, which is more secure because the access token won't be stored in the browser.

TIP: Most client-side OAuth libraries keep access tokens in local storage. However, there is a https://gitlab.com/jimdigriz/oauth2-worker[oauth2-worker] project that allows you to store them in a web worker.

Check out your `master` branch and create a new `jar` one.

[source,shell]
----
git checkout master
git checkout -b jar
----

https://developer.okta.com/blog/2020/03/27/spring-oidc-logout-options

// Deploy JAR to CF


== Package Angular + Spring Boot with Docker

[source,kotlin]
----
plugins {
    ...
    id("com.google.cloud.tools.jib") version "2.2.0"
}
----

java -jar build/libs/*.jar

tasks.jibDockerBuild {
dependsOn("bootJar")
}

./gradlew jibDockerBuild -Pprod --image=bootiful-angular

docker run --publish=8080:8080 bootiful-angular

Copy `notes-api/okta.env` to `src/main/docker/.env`.

Change it to:

[source,shell]
----
OKTA_OAUTH2_ISSUER=https://dev-210914.okta.com/oauth2/default
OKTA_OAUTH2_CLIENT_ID=0oaa7psy3dzvqsPjk4x6
OKTA_OAUTH2_CLIENT_SECRET=FJcSFpTC6NHENPPtb7RRWk6sGwPzYa7d7xPcsWsi
----

./gradlew jibDockerBuild -Pprod
docker run --publish=8080:8080 bootiful-angular


cd src/main/docker
docker-compose -f src/main/docker/app.yml up

// todo: warn about using `build` vs. `bootJar` and tests

Deploy to Docker hub by renaming task from jibDockerBuild to jib and running

 ./gradlew jib -Pprod

// Heroku Docker

[source,shell]
----
heroku create
git remote add jib https://git.heroku.com/enigmatic-woodland-19325.git

// attach old or create PostreSQL and Okta
heroku addons:create heroku-postgresql --remote jib

heroku config:get DATABASE_URL --remote jib
heroku config:set SPRING_DATASOURCE_URL=<value-after-@-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_USERNAME=<username-value-from-last-command> --remote jib
heroku config:set SPRING_DATASOURCE_PASSWORD=<password-value-from-last-command> --remote jib
heroku config:set SPRING_JPA_HIBERNATE_DDL_AUTO=validate --remote jib

// screenshot + commands to match

heroku addons:create okta --remote jib


// See config with
heroku config --remote jib

Remove _WEB from Okta

docker tag hub.docker.com/mraible/bootiful-angular registry.heroku.com/enigmatic-woodland-19325/web
docker push registry.heroku.com/enigmatic-woodland-19325/web
heroku container:release web --remote jib


Add server.port=${PORT:8080} to application-prod.properties and run  ./gradlew jibDockerBuild -Pprod
----

// CF Docker https://docs.cloudfoundry.org/adminguide/docker.html
// Google Cloud and Kubernetes OR KNative

https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#headers


        http.headers()
                .contentSecurityPolicy("script-src 'self'; report-to /csp-report-endpoint/")
                .and()
                .referrerPolicy(ReferrerPolicyHeaderWriter.ReferrerPolicy.SAME_ORIGIN)
                .and()
                .featurePolicy("accelerometer 'none'; camera 'none'; microphone 'none'")

// todo: try logout


./gradlew jib

or

docker image tag bootiful-angular mraible/bootiful-angular
docker push mraible/bootiful-angular

KNative: https://docs.google.com/document/d/1SLEga2V6N_UaxPcEhDku7gViRJflmtFGljgz-OLUNUQ/edit?ts=5eb1f757

https://skaffold.dev/

https://spring.io/blog/2020/01/27/creating-docker-images-with-spring-boot-2-3-0-m1


== KNative

boom! https://bootiful-angular.default.35.184.138.10.nip.io/home

https://docs.google.com/document/d/1SLEga2V6N_UaxPcEhDku7gViRJflmtFGljgz-OLUNUQ/edit#

== Cloud Foundry

cf push -o mraible/bootiful-angular ba
cf cs elephantsql turtle ba-psql
cf bs ba ba-psql
cf env ba  ## this will give u the credentials for the PostgresSQL instance; note them.
cf set-env ba SPRING_DATASOURCE_DRIVER_CLASS_NAME org.postgresql.Driver
cf set-env ba SPRING_DATASOURCE_URL jdbc:postgresql://drona.db.elephantsql.com:5432/rdtfyrue
cf set-env ba SPRING_DATASOURCE_USERNAME rdtfyrue
cf set-env ba SPRING_DATASOURCE_PASSWORD mNgdNG7HxUvzNyMCkGm3NFfNIfL0nv6e
cf set-env ba OKTA_OAUTH2_ISSUER https://dev-210914.okta.com/oauth2/default
cf set-env ba OKTA_OAUTH2_CLIENT_ID 0oaa7psy3dzvqsPjk4x6
cf set-env ba OKTA_OAUTH2_CLIENT_SECRET FJcSFpTC6NHENPPtb7RRWk6sGwPzYa7d7xPcsWsi
cf restage ba


App at http://ba.cfapps.io/home

u can also just use the manifest but make sure to replace the credentials with environment variables using cf set-env

applications:
- name: ba
disk_quota: 1G
docker:
image: mraible/bootiful-angular
env:
OKTA_OAUTH2_CLIENT_ID: 0oaa7psy3dzvqsPjk4x6
OKTA_OAUTH2_CLIENT_SECRET: FJcSFpTC6NHENPPtb7RRWk6sGwPzYa7d7xPcsWsi
OKTA_OAUTH2_ISSUER: https://dev-210914.okta.com/oauth2/default
SPRING_DATASOURCE_DRIVER_CLASS_NAME: org.postgresql.Driver
SPRING_DATASOURCE_PASSWORD: mNgdNG7HxUvzNyMCkGm3NFfNIfL0nv6e
SPRING_DATASOURCE_URL: jdbc:postgresql://drona.db.elephantsql.com:5432/rdtfyrue
SPRING_DATASOURCE_USERNAME: rdtfyrue
instances: 1
memory: 1G
routes:
- route: http://ba.cfapps.io
services:
- ba-psql
stack: cflinuxfs3

basically all of those environment variables should probably be externally specified, non-version controlled environment variable, so its not much gain to use the manifest.yml itself in this case

that YML would live in manifest.yml

and then in the same directory u could run cf push


and it would do the same thing

in this case im not binding the DB to the app it because ur using a docker container, so its too late for the platform to reconfigure itself based on environment variables

if it were a regular .jar or node app or whatever u could cf push -p my.jar and then if u had done cf bs ba ba-psql then the jar in the app would be tampered with a little to inject some code to automatically hydrate a DataSource based on the environment variables that are injected after u bind a data service

u might also wanna do
cf login

before u run the shell script or the manifest.yml


tada! its in production and im going to focus on something else :)

== Learn More About Angular and Spring Boot

https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku
https://devcenter.heroku.com/articles/deploying-executable-jar-files
https://devcenter.heroku.com/articles/deploying-gradle-apps-on-heroku

https://developer.okta.com/blog/2018/07/03/deploy-vue-app-aws
https://developer.okta.com/blog/2018/07/31/use-aws-cloudformation-to-automate-static-site-deployment-with-s3
