---
layout: blog_post
title: "Security Patterns for Microservice Architectures"
author: mraible
description: "Are you securing your microservice architectures by hiding them behind a firewall? That works, but there are better ways to do it."
tags: [microservices, security, security patterns, microservice patterns]
tweets:
- ""
- ""
- ""
image:
---
:toc: macro
:page-liquid:
:experimental:

If you attend a lot of Java ecosystem conferences, you'll think that everyone uses microservices. It's a very popular topic and developers everywhere are interested in learning about them. For good reason too! Microservice architectures are a technique for delivering code faster.

Chris Richardson is a friend and expert on microservices. He suggests a helpful guideline in a recent blog post:

.Why microservices?
[quote, Chris Richardson, When to use the microservice architecture]]
----
IF
  you are developing a large/complex application
AND
  you need to deliver it rapidly, frequently and reliably
  over a long period of time
THEN
  the Microservice Architecture is often a good choice
----

Chris Richardson also runs https://microservices.io/[microservices.io], which lists a number of microservice patterns at the bottom. I noticed that "access tokens" is the only item under security.

In this post, I hope to describe XX patterns for more secure microservices. It's possible many of these will apply to monoliths too, but I'm taking a distributing computing perspective.

In the same vein as Chris's listing, the patterns in this post might not be necessary or needed by everyone. For example, if I say to use Paseto tokens instead of JWT when possible, that's going to be difficult for developers that use Okta or other IdPs that don't offer Paseto.

Below are 10 design decisions I recommend to secure microservice architectures.

[role="no-title"]
toc::[]

== 1. Be Secure by Design

Secure code is the best code. Secure by design means that you bake security into your software design from the beginning. If you have user input, sanitize the data and remove malicious characters.

As engineers, we're taught early on about the importance of creating well-designed software and architectures. You study it and take pride in it. Design is a natural part of creating software.

https://www.manning.com/books/secure-by-design[image:{% asset_path 'blog/security-patterns-microservices/secure-by-design.png' %}[alt=Secure by Design Book,width=150,align=center,role="pull-right img-150px"]]

Design decisions in security architectures should be based on well-known security threats. Reusable techniques and patterns provide solutions for enforcing the necessary authentication, authorization, confidentiality, data integrity, privacy, accountability, and availability, even when the system is under attack.

I like the example from the https://www.manning.com/books/secure-by-design[Secure by Design] book, by Dan Bergh Johnsson, Daniel Deogun, and Daniel Sawano. They show how you can develop a basic `User` object that has a username that's displayed on a page.

[source,java]
----
public class User {
   private final Long id;
   private final String username;

   public User(final Long id, final String username) {
      this.id = id;
      this.username = username;
   }

   // ...
}
----

If you accept any string value for the username, the username could be used for performing XSS attacks. You can fix this with input validation, like the following.

[source,java]
----
import static com.example.xss.ValidationUtils.validateForXSS;
import static org.apache.commons.lang3.Validate.notNull;

public class User {
   private final Long id;
   private final String username;

   public User(final Long id, final String username) {
      notNull(id);
      notNull(username);

      this.id = notNull(id);
      this.username = validateForXSS(username);
   }
}
----

This code is still problematic.

* Developers need to be thinking about security vulnerabilities
* It requires every developer to be a security expert
* It assumes that the person writing the code can think of every potential vulnerability that might occur now or in the future

A better design is to create a `Username` class that encapsulates all of the security concerns.

[source,java]
----
import static org.apache.commons.lang3.Validate.*;

public class Username {
   private static final int MINIMUM_LENGTH = 4;
   private static final int MAXIMUM_LENGTH = 40;
   private static final String VALID_CHARACTERS = "[A-Za-z0-9_-]+";

   private final String value;

   public Username(final String value) {
      notBlank(value);

      final String trimmed = value.trim();
      inclusiveBetween(MINIMUM_LENGTH,
                       MAXIMUM_LENGTH,
                       trimmed.length());
      matchesPattern(trimmed,
                     VALID_CHARACTERS,
                     "Allowed characters are: %s", VALID_CHARACTERS);
      this.value = trimmed;
   }

   public String value() {
      return value;
   }
}

public class User {
   private final Long id;
   private final Username username;

   public User(final Long id, final Username username) {
      this.id = notNull(id);
      this.username = notNull(username);
   }
}
----

This way, your design makes it easier for developers to write secure code.

== 2. Scan Dependencies

80% of the code you deploy to production is composed of 3rd party dependencies. Many of the libraries we use to develop software are dependent on other libraries. This leads to a (sometimes) large chain of dependencies, some of which might have security vulnerabilities.

You can use a scanning program on your source code repository to identity vulnerable dependencies. You should be scanning for vulnerabilities on your main line of code, on released versions of code, as well as new code contributions.

If you're a GitHub user, you can use https://dependabot.com/[dependabot] to provide automated updates via pull requests. There's also security alerts feature you can enable on your repository.

There's also more robust solutions, such as https://snyk.io/[Snyk] and https://jfrog.com/xray/[JFrog Xray].

// drawing of vulnerable dependencies

== 3. Use HTTPS Everywhere

You should use HTTPS everywhere. If you have an HTTP connection, change it to an HTTPS one. Make sure all aspects of your workflow, from Maven repositories to XSDs refer to HTTPS URIs.

HTTPS has an official name: Transport Layer Security (a.k.a., TLS). It's designed to ensure privacy and data integrity between computer applications.

// How HTTPS Works

Let's Encrypt offers free certificates and you can automate renewing them using its API. To use a certificate with Spring Boot, you just need some configuration.

[source,yaml]
.src/main/resources/application.yml
----
server:
  ssl:
    key-store: classpath:keystore.p12
    key-store-password: password
    key-store-type: pkcs12
    key-alias: tomcat
    key-password: password
  port: 8443
----

_Storing passwords and secrets in configuration files is a bad idea. I'll show you how to encrypt keys like this below._

You also might want to force HTTPS. You can see how to do that in https://developer.okta.com/blog/2018/07/30/10-ways-to-secure-spring-boot#1-use-https-in-production[10 Excellent Ways to Secure Your Spring Boot Application].

// how to use let's encrypt certs b/w Node or .NET servers

=== Secure GraphQL APIs

GraphQL uses HTTP, so you don't have to do much from a security perspective. The biggest thing you'll need to do is keep your GraphQL implementation up-to-date. GraphQL relies on doing POST requests for everything. The server you use will be responsible for input sanitization.

If you'd like to connect to a https://developer.okta.com/blog/2019/12/05/react-graphql-integration-guide[GraphQL server with OAuth 2.0 and React], you just need to pass an `Authorization` header.

TIP: Apollo is a platform for building a data graph and Apollo Client has implementations for https://www.apollographql.com/docs/react/[React] and https://www.apollographql.com/docs/angular/[Angular], among others.

[source,js]
----
const clientParam = { uri: '/graphql' };
let myAuth = this.props && this.props.auth;
if (myAuth) {
  clientParam.request = async (operation) => {
    let token = await myAuth.getAccessToken();
    operation.setContext({ headers: { authorization: token ? `Bearer ${token}` : '' } });
  }
}
const client = new ApolloClient(clientParam);
----

Configuring the ApolloClient https://developer.okta.com/blog/2018/11/30/web-app-with-express-angular-graphql[looks similar for Angular].

[source,ts]
----
export function createApollo(httpLink: HttpLink, oktaAuth: OktaAuthService) {
  const http = httpLink.create({ uri });

  const auth = setContext((_, { headers }) => {
    return oktaAuth.getAccessToken().then(token => {
      return token ? { headers: { Authorization: `Bearer ${token}` } } : {};
    });
  });

  return {
    link: auth.concat(http),
    cache: new InMemoryCache()
  };
}
----

On the server, whatever you use to secure your REST API endpoints can be used to secure GraphQL.

=== Secure RSocket Endpoints

RSocket is a next-generation, reactive, layer 5 application communication protocol for building today's modern cloud-native and microservice applications.

What does all that mean? It means RSocket has reactive semantics built-in, so it can communicate backpressure to clients and provide more reliable communications. The https://rsocket.io/[RSocket website] says implementations are available for Java, JavaScript, Go, .NET, C++, and Kotlin.

TIP: https://docs.spring.io/spring-security/site/docs/5.3.0.RELEASE/reference/html5/#rsocket[Spring Security 5.3.0 has full support for securing RSocket applications].

To learn more about RSocket, I recommend reading https://spring.io/blog/2020/03/02/getting-started-with-rsocket-spring-boot-server[Getting Started With RSocket: Spring Boot Server].

== 4. Access Tokens + Identity

OAuth 2.0 has provided delegated authorization since 2012. OpenID Connect added federated identity on top of OAuth 2.0 in 2014. Together, they provide a standard spec you can write code against, and have confident that it will work across IdPs (Identity Providers).

If you're communicating between microservices, you can use OAuth 2.0's client credentials flow to implement https://developer.okta.com/blog/2018/04/02/client-creds-with-spring-boot[secure server-to-server communication].

// graph of server-to-server

The spec also allows you to look up the identity of the user by sending an access token to the `/userinfo` endpoint. The URI for this endpoint can be looked up using OIDC discovery, providing a standard way to obtain a user's identity.

// /userinfo endpoint graphic

=== Auth Servers: One or Many?

// graphs + pros and cons

=== Use Paseto Tokens Over JWT

https://paseto.io/

Paseto is everything you love about JOSE (JWT, JWE, JWS) without any of the many design deficits that plague the JOSE standards.

Brian digs it - checkout [blog post] and [video].

== 5. Verify Security with Delivery Pipelines

Dependency and constainer scanning should be part of your source control monitoring system, but you should also perform tests when executing your CI (continuous integration) and CD (continous deliver) pipelines.

Atlassian has an informative blog post titled https://www.atlassian.com/continuous-delivery/principles/devsecops[DevSecOps: Injecting Security into CD Pipelines].

> The term DevSecOps is used to describe a security focused, continuous delivery, software development life cycle (SDLC).

// devsecops - funny cartoon

Most of the above mentioned suggestions can actually be automated in your code delivery pipeline as part of a series of checks in security. To learn about a more "Continuous Hacking" approach to software delivery, this article provides more detail.

== 6. Use Docker Rootless Mode

Use Docker Rootless mode https://hub.packtpub.com/docker-19-03-introduces-an-experimental-rootless-docker-mode-that-helps-mitigate-vulnerabilities-by-hardening-the-docker-daemon/

Is this worthy on its own? Should I talk about Dockerfile or Jib?

== 7. Encrypt and Protect Secrets

// environment variables
// encrypted keys in CI servers
// hashicorp vault && spring vault
// AWS - Randall?
// .NET solution?

== 8. Use Time-based Security

- InfoQ Podcast https://www.infoq.com/podcasts/web-security-hack-anatomy/
- Briefly describe attack story
- MFA
- Alerts for successful logins

== 9. Scan Docker and Kubernetes Configuration for Vulnerabilities

// talk to Snyk guy from Jfokus

== 10. Know Your Cloud and Cluster Security

If you're managing your production clusters and clouds, you're probably aware of https://kubernetes.io/docs/concepts/security/#the-4c-s-of-cloud-native-security[the 4C's of Cloud Native Security].

image::{% asset_path 'blog/security-patterns-microservices/4c-cloud-native-security.png' %}[alt=The 4C's of Cloud Native Security,width=700,align=center]

As you can see from the above figure, each one of the 4C's depend on the security of the squares in which they fit. It is nearly impossibly to safeguard against poor security standards in Cloud, Containers, and Code by only addressing security at the code level. However, when these areas are dealt with appropriately, then adding security to your code augments an already strong base.

// describe more about what the site is, tests it recommends, etc.

Be able to throttle down during an attack. Make it so it's not worth the attacker's time.

// Most of the above mentioned suggestions can actually be automated in your code delivery pipeline as part of a series of checks in security. To learn about a more "Continuous Hacking" approach to software delivery, https://thenewstack.io/beyond-ci-cd-how-continuous-hacking-of-docker-containers-and-pipeline-driven-security-keeps-ygrene-secure/[this article provides more detail].

== Learn More About Microservices and Web Security

// wrap up

// links

// follow
