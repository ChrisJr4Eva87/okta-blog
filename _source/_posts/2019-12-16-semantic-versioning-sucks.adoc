---
layout: blog_post
title: "Semantic Versioning Sucks!"
author: mraible
description: "Semantic versioning is a mechanism to convey compatibility between releases. Why does it suck so bad?"
tags: [versioning, semantic, semantic versioning]
tweets:
- "Semantic versioning sucks! Here's how to fix it."
- "Semantic versioning seems like a good idea. Why does it cause things to be broken all the time?"
- "Is there any hope for semantic versioning?"
image: // todo
---

Hello, fellow developers.

Have you ever been bitten by semantic versioning? I have. It's a great idea at it's core, but implemented badly, it sucks. I've been a developer since mid-90s and it only seems to have gotten worse recently. I started as a developer doing HTML, JavaScript, and CSS. In the early 2000s, I started learning and using Java.

Semantic versioning sucks because of the human element. Because people release minor versions without backward compatibility _all-the-time_.

In the early days, I don't recall having much of a problem with dependencies and their versions. Back then, Java developers would use their IDE for everything, or Ant with their dependencies (aka JAR files) checked into source control. In essence, everything was "locked down" and there were no transitive dependencies.

Before I go any further, let me answer **what is semantic versioning**?

It's a naming system for version numbers of software releases. It's commonly used by open source projects. According to https://semver.org/[semver.org], given a version number `MAJOR.MINOR.PATCH`, you should:

. `MAJOR` version when you make incompatible API changes,
. `MINOR` version when you add functionality in a backwards compatible manner, and
. `PATCH` version when you make backwards compatible bug fixes.

== Why Does Semantic Versioning Suck?

Semantic versioning sucks because of transitive dependencies. Back in the day, when you had all your dependencies in source control, there were no additional dependencies pulled in. Today, there's tools like Maven/Gradle (for Java) and npm for Node. These build tools read a set of dependencies, download them (including the dependencies they depend on), and make it so your project can read them and compile everything.

Maven and Gradle have been criticized for "downloading the internet". If you think they're bad, you should see npm. It downloads the internet and invites all its friends to come along!

This is not the fault of the build tool, but often the library authors who depend on all kinds of third-party libraries.

In Java-land, we learned early that version ranges are a bad idea. If you want them, you _can_ use them, but most people don't. Here's how they work:

* `[1.0, 2.0]`: all versions >= 1.0 and <= 2.0
* `[1.0, 2.0[`: all versions >= 1.0 and < 2.0
* `[1.0, )` : all versions >= 1.0

Node, on the other hand, _encourages_ ranges. Even if you don't want to use them, chances are your downstream dependencies are. This doesn't happen often in Java libraries.

Node has an https://github.com/npm/node-semver#advanced-range-syntax[advanced range syntax] with hyphens, x-ranges, tilde ranges, and caret ranges.

* Hyphen ranges specify an inclusive set: `1.2.3 - 2.3.4` means `>=1.2.3 <=2.3.4`
* X-Ranges allow `X`, `x`, or `*` to specify the numeric values in the `[major, minor, patch]`
* Tilde ranges allow patch-level changes if a minor version is specified, `~1.2.3` means `>=1.2.3 <1.3.0`
* Caret ranges allow changes that do no modify the left-most non-zero element. This means you'll get patch and minor updates for version 1.0.0 and above.

Why does Node encourages ranges so much? The https://jubianchi.github.io/semver-check[Online Semver checker] says:

> Strict constraint (or fully qualified constraint) are those constraints matching only one version. In most case it is a bad idea to use them.
>
> Why? Because with them you are locking your dependency to a specific patch release which means you won't ever get bug fixes when updating your dependencies.

I like the ideas behind this statement. It would be nice to get bug fixes and security updates from patch releases. However, using ranges for versions means that incompatible versions can sneak in. And builds might not be reproducible if a downstream patch release happens between builds.

== Examples Where Semantic Versioning Sucked in 2019

I've personally experienced some times when semantic versioning killed my productivity in 2019.

https://jhipster.tech[JHipster] is an application generator that uses Java on the backend (with Maven or Gradle) and npm for the frontend. It doesn't use version ranges in its `package.json`, but still had issues caused by downstream releases. The project experienced three issues in 2019:

. https://github.com/jhipster/generator-jhipster/issues/9438[#9438] React Router (broke React)
. https://github.com/jhipster/generator-jhipster/issues/9952[#9952] Inquirer (broke all prompts)
. https://github.com/jhipster/generator-jhipster/issues/10371[#10371] Terser (broke Angular entity screens)

None of these problems where caused by versions specified in `package.json`. They were all caused by downstream dependencies releasing new versions and breaking things!

I also got blocked (along with many others) by Ionic CLI v5.4.1. The version had https://github.com/ionic-team/starters/issues/942[issues] caused by a https://github.com/isaacs/minipass/issues/9[patch release of minipass]. This took three days to fix and I was blocked from testing changes to the JHipster Ionic Starter during it. No new release of Ionic CLI was required, you just had to uninstall/reinstall after minipass released another patch release.

A wide sweeping patch update that affected react-scripts, Angular CLI, and Ionic CLI was a https://github.com/zloirock/core-js/issues/712[minor release of core-js]. I didn't experience this problem personally, but it does seem like it was fixed in the same day.

I also experienced an issue in 2018 where the TypeScript support for Create React App didn't work for a two hour period. That period happened to be when I was on stage demoing React at Spring One. You can watch my failure https://youtu.be/fiR7MWoTYjs?t=2462[here] and find the cause in https://twitter.com/mraible/status/1045345722449768449[this Twitter thread].

== What Can We Do to Make Semantic Versioning Better?

The Java projects I use don't seem to have semantic versioning issues. I believe this is because no one uses version ranges in Java. If there's a new downstream release that fixes a critical bug, the upstream library does a new release. Builds are always reproducible.

I'm not sure if there's a good solution in the Node community. There's millions of libraries and most development guides encourage ranges and say strict versions are a bad idea. In theory, it sounds good, but it only works if developers strictly adhere to semantic versioning.

JHipster doesn't use version ranges for Angular, React, and Vue, yet we still experience issues. Yarn's https://yarnpkg.com/lang/en/docs/selective-version-resolutions/[selective version resolutions] does help, and it's what JHipster often uses to lock downstream dependency versions. For example, adding the following to your `package.json` makes sure you get a version of handlebars without a security vulnerability.

[source,json]
----
"resolutions": {
  "handlebars": "4.5.3"
}
----

However, this only works with Yarn. The good news is you can use https://www.npmjs.com/package/npm-force-resolutions[npm-force-resolutions] for npm users. You just need to add a `preinstall` script.

[source,json]
----
"scripts": {
  "preinstall": "npx npm-force-resolutions"
}
----

== Automate Semantic Versioning

Semantic versioning is a good idea. It would be a great idea if there were tools that automatically assigned the version based on comparing the current version to a previous version. Assigning the version number for a release seems to be mostly a manual task.

If we could automate the version number assignment, I think Node projects would experience a lot less issues. Of course, then you'd have to get all developers to adopt it, so that might be tough. Then again, if it was built into npm (like `npm audit` for security vulnerabilities), then we might be onto something!

== How Experts Do Semantic Versioning

// Les for JJWT and Brian for Okta Boot Starter
// Phill Web for Spring Boot
// Juergen for Spring Framework
// Julien, Deepu, and Pascal for JHipster
// Minko Gechev for Angular

== Good Luck!
